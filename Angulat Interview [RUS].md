## Вопросы для подготовки к собеседованию

### Меню
- ### Общий блок
	
	[//]: # "Как устроен браузер?"

	<details>
	<summary>
		<h4>
			<b>Как устроен браузер?</b>
		</h4>
	</summary>
	<div>
	<img src="https://habrastorage.org/webt/dl/fr/hh/dlfrhh43eqb66arhgeic_h6e_8c.png" alt="Браузер под капотом"/>

	- ***User Interface*** — это все что видит пользователь: адресная строка, кнопки вперед/назад, меню, закладки — за исключением области, где отображается сайт.  
	- ***Browser Engine*** отвечает за взаимодействие между User Interface и Rendering Engine. Например, клик по кнопке назад должен сказать компоненте RE, что нужно отрисовать предыдущее состояние.
	- ***Rendering Engine*** отвечает за отображение веб-страницы. В зависимости от типа файла, эта компонента может парсить и рендерить как HTML/XML и CSS, так и PDF.  
	- ***Network*** выполняет xhr запросы за ресурсами, и в целом, общение браузера с остальным интернетом происходит через эту компоненту, включая проксирование, кэширование и так далее.  
	- ***JS Engine*** место, где парсится и исполняется js код.  
	- ***UI Backend*** используется чтобы рисовать стандартные компоненты типа чекбоксов, инпутов, кнопок.  
	- ***Data Persistence*** отвечает за хранение локальных данных, например в куках, SessionStorage, indexDB и так далее.

	Link:
	- [Рендеринг веб сайтов 101](https://habr.com/ru/post/484900/)
	</div>
	</details>
	
	[//]: # "Как рендерится WEB-страница?"

	<details>
	<summary>
		<h4>
			<b>Как рендерится WEB-страница?</b>
		</h4>
	</summary>
	<div>
	<img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000545/images/hpbn_1001.png" alt="Общая схема"/>

	Последовательность работы браузера при отображении документа:
	 1. ***Формируется DOM (Document Object Model)*** из полученного от сервера HTML-документа
	 2. ***Формируется CSSOM (CSS Object Model)*** путем загрузки и распознавания стилей
	 3. ***Формируется дерево рендеринга (Render Tree)*** — набор объектов рендеринга (Webkit использует термин «renderer», или «render object», а Gecko — «frame») на основе DOM и CSSOM Render tree описывает визуальное представление DOM. <br/><br/> *Render tree дублирует структуру DOM, но сюда не попадают невидимые элементы (например — `<head>`, или элементы со стилем `display:none;`). Каждая строка текста будет представлена как отдельный renderer. Каждый объект рендеринга содержит соответствующий ему объект DOM (или блок текста), и рассчитанный для этого объекта стиль*

	 4. ***Рассчитывается положение на странице (layout)*** для каждого элемента render tree. Браузеры используют поточный метод (flow), при котором в большинстве случаев достаточно одного прохода для размещения всех элементов (для таблиц проходов требуется больше)

	 5. ***Отрисовка браузером страницы пользователю (painting)***

	В процессе взаимодействия пользователя со страницей, а также выполнения скриптов, она меняется, что требует повторного выполнения некоторых из вышеперечисленных операций.

	***Repaint (Restyle)*** - отрисовка элемента заново с новым стилем в случае изменения стилей элемента, не влияющих на его размеры и положение на странице (например, `background-color`, `border-color`, `visibility`).

	***Reflow (Relayout)*** - перерасчет положения элемента, если изменения затрагивают содержимое, структуру документа, положение элементов. Причинами таких изменений обычно являются:
	-   Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов);
	-   Изменение содержимого, в т.ч. текста в полях форм;
	-   Расчёт или изменение CSS-свойств;
	-   Добавление, удаление таблиц стилей;
	-   Манипуляции с атрибутом «`class`»;
	-   Манипуляции с окном браузера — изменения размеров, прокрутка;
	-   Активация псевдо-классов (например,  `:hover`)

	**Оптимизация со стороны браузера**
	Браузеры по возможности ***локализуют repaint и reflow*** в пределах элементов, подвергнувшимися изменению. Например, изменение размеров абсолютно или фиксировано спозиционированного элемента затронет только сам элемент и его потомков, в то время как изменение статично спозиционированного — повлечет reflow всех элементов, следующих за ним.  

	Во время выполнения JavaScript браузеры кэшируют вносимые изменения, и применяют их ***в один проход*** по завершению работы блока кода. Но бращение к свойствам элементов вызовет ***принудительный reflow***.

	</div>
	</details>
	
	[//]: # "Практические советы по оптимизации"

	<details>
	<summary>
		<h4>
			<b>Практические советы по оптимизации</b>
		</h4>
	</summary>
	<div>
		
	Советы, которые пригодятся при создании эффективного фронтенда  
		
	-   Пишите валидный HTML и CSS, с указанием кодировки. Стили лучше включать в  `<head>`, а скрипты — в конце  `<body>`.
	-   Стремитесь упрощать и оптимизировать селекторы CSS. Чем меньше вложенность — тем лучше. По эффективности обработки селекторы можно расположить в следующем порядке (начиная с наиболее быстрого):  
		
	    1.  Идентификатор:  `#id`
	    2.  Класс:  `.class`
	    3.  Тэг:  `div`
	    4.  Соседний селектор:  `a + i`
	    5.  Дочерний селектор:  `ul > li`
	    6.  Универсальный селектор:  `*`
	    7.  Селектор атрибутов:  `input[type="text"]`
	    8.  Всевдоэлементы и псевдоклассы:  `a:hover`

		
	Следует помнить, что браузер обрабатывает селекторы справа налево, поэтому в качестве ключевого (крайнего правого) селектора лучше использовать наиболее эффективные — идентификатор и класс.  

		    ```
		    div * {...} // плохо
		    .list li {...} // плохо
		    .list-item {...} // хорошо
		    #list .list-item {...} // хорошо
		    ```

	-   В скриптах минимизируйте любую работу с DOM. Кэшируйте всё: свойства, объекты, если подразумевается повторное их использование. При сложных манипуляциях разумно работать с «offline» элементом (т.е. который находится не в DOM, а в памяти), с последующим помещением его в DOM.  
	-   Для изменения стилей элементов лучше модифицировать только атрибут «`class`», и как можно глубже в дереве DOM, это и более грамотно с точки зрения разработки и поддержки (отделение логики от представления), и менее затратно для браузера.
	-   Анимировать желательно только абсолютно и фиксировано спозиционированные элементы.
	-   Можно отключать сложные :hover анимации во время скроллинга (например, добавляя к body класс «`no-hover`»).

	Links:
	- [Рендеринг WEB-страницы: что об этом должен знать front-end разработчик](https://habr.com/ru/post/224187/)
	- [Рендеринг веб сайтов 101](https://habr.com/ru/post/484900/)
	- [Техническое описание  с браузерными инструментами](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ru)
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое HTTP?</b>
		</h4>
	</summary>
	<div>
		<img src="https://www.clickminded.com/wp-content/uploads/client-and-server-communication-protocols.png" alt="HTTP"/>
		
	***HTTP*** - протокол прикладного уровня, предназначенный для передачи данных по сети. 
	</div>
	</details>	
			
	<details>
	<summary>
		<h4>
			<b>Из чего состоит HTTP запрос?</b>
		</h4>
	</summary>
	<div>
	Состав:
		
	- ***строка запроса (Request Line)*** - метод передачи, url и версию hhtp
	- ***заголовки (Message Headers)*** - дополнительные сведения
	- ***\n*** - разделитель
	- ***тело сообщения (Entity Body)*** - может отсутсвовать, сами данные
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое websockets?</b>
		</h4>
	</summary>
	<div>
	
	***Websockets*** - протокол для взаимодействия в реальном времени. Участники устанавливают соединение и общаются до его завершения.
		
	</div>
	</details>
		
		
	<details>
	<summary>
		<h4>
			<b>Что такое Rest API?</b>
		</h4>
	</summary>
	<div>
	<img src="https://miro.medium.com/max/1400/1*f-4u01cDYiy6N5IRBktZnw.png" alt="Rest API"/>
		
	***Rest*** - один из самых популярных архитектурных подходов, который подразумевает взаимодействие клиент-сервер. Разделение разных операций CRUD через отдельные методы HTTP.
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Анализ CSS</b>
		</h4>
	</summary>
	<div>
		Когда браузер отображает документ, он <b>должен совместить содержимое со стилями</b>. Этот процесс идёт в несколько этапов, о которых мы сейчас поговорим.

	Обобщенная версия (там все сложнее, и зависит от браузера):
	1.  Браузер получает HTML-страницу 
	2.  Преобразует  [HTML](https://developer.mozilla.org/ru/docs/Glossary/HTML)  в  [DOM](https://developer.mozilla.org/ru/docs/Glossary/DOM)  (_Document Object Model_).
	3.  Браузер загружает все ресурсы и описания, связанные с HTML-документом, например: встроенные картинки, видео ... и стили CSS! 
	4.  Браузер анализирует полученный CSS код, сортирует описанные там правила в зависимости от их селекторов и раскладывает их в различные «корзины»: элементы, классы, идентификаторы(ID) и т.п. Основываясь на найденных селекторах браузер понимает какие правила относятся к определённым «узлам» в DOM-дереве и применяет их по мере необходимости (этот промежуточный шаг называют «формированием дерева представления» или «формированием дерева рендеринга»)
	5.  Дерево представления (_render tree_) формируется в том порядке, в каком оно затем должно будет отображаться, когда все правила будут применены.
	6.  Затем происходит визуальное отображение контента на странице (этот этап называется «отрисовкой»)

		
	<img src="https://mdn.mozillademos.org/files/17080/Browser_simple_rendering_pipeline__ru.png" alt="Диаграмма"/>

		
	Если браузер встретит свойство, которое он не понимает, он просто-напросто проигнорирует его и двинется дальше. Он сделает так, если программист допустил опечатку или ошибку в свойстве или значении или если браузер не поддерживает какое-либо свойство или значение.

		
	Link:
	- [# Как работает CSS](https://developer.mozilla.org/ru/docs/Learn/CSS/First_steps/How_CSS_works)

		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Оптимизация CSS</b>
		</h4>
	</summary>
	<div>
	Деление на группы селекторов по эффективности обработки (начиная с более быстрого):
	<img src="https://webformyself.com/wp-content/uploads/2018/294/1.jpg" alt="Группы селекторов по эффективности обработки"/>
		
	Браузеры читают CSS <b>справа налево</b>. Самый правый селектор в составном селекторе известен как селектор key. Так, например, в #id .class > ul a, селектор key является a. 

	*Браузер сначала находит все элементы на странице, которые соответствуют селектору. Затем он находит все элементы ul на странице и фильтрует a до тех же элементов, которые являются потомками ul, и так далее, пока не достигнет крайнего левого селектора.*

	Поэтому чем короче селектор, тем лучше. Если возможно, убедитесь, что селектор key является классом или идентификатором, чтобы сохранить его быстрым и конкретным.

	***Качество важнее количества***

	Большая проблема просто наличия дорогих селекторов — их много. Примерами проблемы ***«раздувание стиля»*** являются сайты, которые импортируют целые фреймворки CSS, такие как Bootstrap или Foundation, при использовании менее 10% переданного CSS. Другой пример можно увидеть в старых, никогда не рефакторизованных проектах, чей CSS теперь больше похож на заросший сад, полный сорняков.

	Мало того, что большой файл CSS занимает больше времени для передачи (сеть является самым узким местом в производительности веб-сайта), они также занимают больше времени для синтаксического анализа. Помимо построения DOM из вашего HTML, браузеру необходимо построить CSSOM (объектную модель CSS), чтобы сравнить его с DOM и сопоставить селекторы.

	Итак, держите свои стили стройными и сухими, не включайте все и кухонную раковину, загружайте то, что вам нужно, и когда вам это нужно.

	Link:
	- [Оптимизация CSS: идентификаторы и другие мифы](https://webformyself.com/optimizaciya-css-identifikatory-i-drugie-mify/)
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Еще немного о Repaint и Reflow</b>
		</h4>
	</summary>
	<div>
	<b>Repaints and reflows</b>
		
	При загрузке страницы, если она не пустая, всегда выполняется, как минимум, по одному reflow и repaint. Далее эти события возникают в следующих случаях:  
	 - Часть дерева отображения нуждается в перерасчете, т. е. у какого-то узла изменились ширина, высота или координаты. Вызывается событие <b>reflow</b>.  
	 - В результате изменений часть отображаемого контента должна обновиться. Речь идет, в первую очередь, о свойствах стилей: цвет фона, радиус и т. д. Вызывается событие <b>repaint</b>.  

	<b>Если вызывается reflow, после него обязательно вызовется и repaint</b>. Но <b>обратное неверно</b>: repaint может вызываться независимо от reflow.

	**Какие действия вызывают reflow и/или repaint**:
	**1) Добавление, обновление, удаление DOM-узла.** Потому что при этих событиях нужно перерасчитывать дерево отображения.  
	- ***Функции***:  
	  - insertAdjacentHTML()
	  - appendChild()
	  - insertBefore()
	  - removeChild()
	  - replaceChild()
	  - remove()
	  - append()/prepend()
	  - after()/before()
	  - replaceWith()  
		
	- ***Изменение свойств DOM-узла***:  
	  - innerHTML
	  - innerText
	  - width
	  - height
	  - offsetTop
	  - offsetLeft
	  - offsetWidth
	  - offsetHeight
	  - scrollTop/Left/Width/Height
	  - clientTop/Left/Width/Height  

	- ***Запрос свойств DOM-узла без его изменения***:  
	  - offsetTop
	  - offsetLeft
	  - offsetWidth
	  - offsetHeight
	  - scrollTop/Left/Width/Height
	  - clientTop/Left/Width/Height  

	Простой запрос некоторых свойств может вызвать reflow, к которым, в частности, относятся все офсет-свойства. 

	При запросе этих свойств браузеру нужно выполнить перекомпоновку незамедлительно, т. к. они должны возвращать актуальную информацию. Поэтому всякий раз, когда мы запрашиваем эти свойства, происходят reflow и repaint.

	**2) Скрытие DOM-узла** с помощью ***display: none*** (reflow и repaint) или ***visibility: hidden*** (только repaint, потому что нет геометрических изменений).  

	**3) Перемещение, анимация DOM-узла.**  
	Меняются координаты анимируемого узла дерева отображения, что может вызывать изменение размеров других узлов.  

	**4) Добавление/изменение CSS**    
	Если мы захотим изменить left, top,right,bottom,width,height css-свойства, это тоже вызовет reflow.  

	**5) Пользовательские действия**: изменение размеров окна (resize), изменение шрифта, прокрутка(scroll), drag and drop.  

	**6) Другое**  
	 - JS Scrolling_: 
	   - Скроллинг через скрипт и соответствующие ему свойства.  
	scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft, scrollTop, scrollWidth  
	-  Глобальные методы и события для объекта window:_  
	   - getComputedStyle(), scrollBy(), scrollTo(), scrollX, scrollY  
	- Работа с SVG

	 Link:
	 - [Repaints и reflows — и принципы работы event loop](https://habr.com/ru/company/dataart/blog/304934/)
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Свойство display - какие значения принимает и как они работают?</b>
		</h4>
	</summary>
	<div>
	Основные значения
		
	- <b>none</b> - элемент не показывается на экране
	- <b>block</b> - блочные элементы, располагаются друг над другом вертикально. Стремится расшириться на всю доступную ширину.
	- <b>inline</b> - элементы располагаются на одной строке последовательно. Ширина и высота определяются по содержимому, изменить их нельзя.
	- <b>inline-block</b> - элемент является строчным, но ему можно менять высоту и ширину.
	- <b>flex</b> - более сложный вариант
	- <b>grid</b> - более сложный вариант
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Какие бывают значения у свойства position?</b>
		</h4>
	</summary>
	<div>
	Основные значения
		
	- <b>static</b> - статическое позиционирование по умолчанию
	- <b>relative</b> - позиционирование сдвигаетс относительно его обычного положения. С помощью свойств top, left, right и bottom
	- <b>absolute</b> - позиционируется заново. Остальные элементы позиционируются так, будто его нет. Свойства top, left, right и bottom отсчитываются от ближайшего позиционированного родителя или же от всего документа, если нет родителя
	- <b>fixed</b> - похоже на absolute за исключением того, что fixed крепится к определенной части экрана и находится там даже с учетом прокрутки.
	- <b>sticky</b> - похож на fixed, но крепится внутри блока, а не документа
	</div>
	</details>

	<details>
	<summary>
		<h4>
			<b>Как отцентровать блок по горизонтали и вертикали?</b>
		</h4>
	</summary>
	<div>
	На данный момент самый простой способ:

	    display: flex;
	    justify-content: center; // по горизонтали
	    align-items: center; // по вертикали

	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что делает box-sizing: border-box?</b>
		</h4>
	</summary>
	<div>
		При использовании этого свойства ширина и высота будут <b>включать в себя</b> <b>padding</b> и <b>border</b>, но не <b>margin</b>.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое Inline стили и какой у них приоритет?</b>
		</h4>
	</summary>
	<div>
	<b>Inline стили</b> пишутся в html и имеют самый высокий приоритет.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое БЭМ?</b>
		</h4>
	</summary>
	<div>
	<b>БЭМ</b> - это методология <b>Блок-Элемент-Модификатор</b>, которая подразумевает компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки, позволяющий легко и быстро разворачивать интерфейсы любой сложности и повторно использовать код.
	</div>
	</details>
	
	<details>
	<summary>
		<h4>
			<b>Что такое vh и vw?</b>
		</h4>
	</summary>
	<div>
	<b>vh</b> - 1% от высоты окна браузера
	<b>vw</b> - 1% от ширины окна браузера
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Из чего строится размер элемента?</b>
		</h4>
	</summary>
	<div>
	Размер элемента строится из:
	- <b>размеров содержимого</b>
	- <b>внутренних отступов</b>
	- <b>рамки</b>
	- <b>внешних отступов</b>
	</div>
	</details>
	
	<details>
	<summary>
		<h4>
			<b>За что отвечает z-index?</b>
		</h4>
	</summary>
	<div>
	<b>z-index</b> управляет вертикальным порядком расположения элементов, которые перекрываются. Z-index влияет на все элементы, где position не равно static. 
	Без заданного значения они появляются в том порядке, в котором заданы в DOM.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое псевдоклассы и какие вы используете чаще всего?</b>
		</h4>
	</summary>
	<div>
	<b>Псевдоклассы</b> описывают характеристики элементов, такие как динамическое состояние. Не отображаются в документе и не принадлежат DOM.

	Часто используемые: :focus, :checked и :hover
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Как увеличить в размере элемент, не сдвигая соседние?</b>
		</h4>
	</summary>
	<div>
	Используя свойство transform: scale() и другие. 
	</div>
	</details>
		
- ### Про JS
	
	<details>
	<summary>
		<h4>
			<b>Типы данных в JS</b>
		</h4>
	</summary>
	<div>
		
	***8 типов данных***:
	- ***null*** - примитивный тип
	- ***undefined*** - примитивный тип
	- ***boolean*** - примитивный тип 
	- ***number*** - примитивный тип
	- ***string*** - примитивный тип
	- ***object*** - простая структура данных
	- ***symbol*** - примитивный тип
	- ***bigint*** - примитивный тип

		
	Кавычки "", '' и `` - литералы, в которые мы можем вставлять динамические данные через ${}

	Оператор ***typeof*** возвращает тип данных  в виде строки.
	***Особенности typeof***:
	- ***typeof null - object***, хотя на самом деле Null
	- ***typeof function() {} - function***, хотя на самом деле Object
	- ***typeof NaN - number***, хотя значит дословно не число

		
	***Undefined*** - переменная не объявлена или объявлена через var без присвоенного значения. Void функции также возвращают undefined.
	***Null*** - отсутствие значение, мы ее обнулили сами.

	Приведение типов явное через обертки или неявное внутри функций.
	Есть всегда false значения ***'', 0, null, undefined, NaN, false***, а остальные значения дают true.
	***Оператор сложения*** определен для string, поэтому если первая переменная string, то приведение будет к строке.
	***Остальные математические операции*** будут приводить все переменные к number. Если не получится привести, то NaN.

	Сравнение ***==*** и ***===***
	- ***==*** сравнивает с приведением типов
	- ***===*** сравнивает без приведения типов

	Неоднозначные сравнения, потому что приведение в данном случае идет своим особенным алгоритмом:
	- ***console.log(false == '')*** - true
	- ***console.log(false == [])*** - true
	- ***console.log(false == {}***) - false <br/><br/>
	- ***console.log('' == 0)*** - true
	- ***console.log('' == [])*** - true
	- ***console.log('' == {})*** - false <br/><br/>
	- ***console.log(0 == [])*** - true
	- ***console.log(0 == {})*** - false
	- ***console.log(0 == null)*** - false
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Какими способами можно объявить переменную?</b>
		</h4>
	</summary>
	<div>
		
		a = 5
		var b = 10
		let c = "let"
		const obj = {}
   
	Первые два способа создают переменную ***глобальной*** или же ***функциональной*** области видимости, но не имеют блочной. Такой способ ***является устаревшим***.
	`let` и `const` имеют ***блочную*** область видимости.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>В чем разница между null и undefined?</b>
		</h4>
	</summary>
	<div>
		
	Оба обозначают пустое значение. 
	Если мы создаем переменную, но ***не инициализируем*** ее значение, то в нее помещается специальный маркер, отображающийся как ***undefined***.
	***null*** мы ***присваеваем самостоятельно***, что означает ничего или пусто, например, для очистки значения переменной. 
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Для чего нужны map, filter, reduce, forEach , каковы особенности использования?</b>
		</h4>
	</summary>
	<div>
		
	***forEach() ничего не возвращает***, а просто итерируется по исходному массиву. Более элегантный перебор, чем цикл for().
	***map()*** и ***filter()*** возвращают новый массив. Первый используется для трансформации и вернет массив элементов, к каждому из которых была применена функция-callback. Второй применяется для фильтрации и вернет массив из тех элементов, для которых функция-callback вернет true.
	***reduce()*** возвращает результат выполнения. Применяется для последовательной обработки элементов массива.
	
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Отличие стрелочных функция от функций, объявленных через function?</b>
		</h4>
	</summary>
	<div>
		
	- Синтаксис
	- Стрелочные функции не имеют arguments
	- У стрелочных функций нет своего this. Если идет обращение к this, то оно берется снаружи
	- Не могут быть вызваны с помощью  оператора new
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое шаблонные литералы и для чего они нужны?</b>
		</h4>
	</summary>
	<div>

	Шаблонные литералы - это ***косые кавычки***.
	- В них разрешен перенос строки
	- Можно вставлять выражения при помощи ${}
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое set и map?</b>
		</h4>
	</summary>
	<div>

	***Map*** - это коллекция ключ/значение, как и Object. Основное отличие в том, что Map позволяет использовать ключи любого типа.

	***Set*** - это коллекция (множество), совего рода массив, где каждое значение может появляться только один раз.
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Какие есть falsy значения?</b>
		</h4>
	</summary>
	<div>
		
	В JavaScript есть только ***7 ложных*** значений.
	Это означает, что когда JavaScript ожидает логическое значение и ему присваивается одно из значений ниже, оно всегда будет оцениваться как ложное:
	- false
	- 0
	- ""
	- null
	- undefined
	- NaN
	- BigInt(0)
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое Promise?</b>
		</h4>
	</summary>
	<div>
		
	***Promise*** - это специальный объект, предназначенный для работы с асинхронным кодом и который содержит свое состояние. Вначеле ***pending***(«ожидание»), затем ***fulfilled***(«выполнено успешно») или ***rejected***(«выполнено с ошибкой»).
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Как использовать async/await для асинхронных запросов?</b>
		</h4>
	</summary>
	<div>

	***Async/await*** - это специальный синтаксис для работы с промисами. То есть функция, помеченная async, будет ***оборачивать результат*** в Promise. 

	Функция помечается async, что позволяет использовать внутри await перед асинхронными операциями, что позволит выполнять код ***синхронно***.
	</div>
	</details>

	<details>
	<summary>
		<h4>
			<b>Для чего нужен оператор spread?</b>
		</h4>
	</summary>
	<div>
	Оператор ... имеет множество предназначений. 
	Конкретно spread предназначен, чтобы разворачивать массивы и объекты.

	    let mid = [3,4];
	    let arr = [1,2,mid,5,6] // Получим [1,2,[3,4],5,6]

	    let mid = [3,4];
	    let arr = [1,2,...mid,5,6] // Получим [1,2,3,4,5,6]

	</div>
	</details>	
		
	<details>
	<summary>
		<h4>
			<b>Как избежать ссылочной зависимости при копировании объекта?</b>
		</h4>
	</summary>
	<div>

	***Object.assign()*** для вложенных объектов скопирует только ссылку, то есть сложный объект будет скопирован только частично. 
		
	Давний костыльный способ `JSON.parse(JSON.stringify(object))`. То есть получим полную копию.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое тернарный оператор?</b>
		</h4>
	</summary>
	<div>

	Это аналогичный if - else оператор, который единственный имеет 3 аргумента. Представлен знаком `?`

    		let result = условие ? тогда : иначе;
	</div>
	</details>	
	
	<details>
	<summary>
		<h4>
			<b>Что такое деструктуризация?</b>
		</h4>
	</summary>
	<div>

	***Деструктурирующее присваивание*** - специальный синтаксис, позволяющий распаковать массив/объект в переменные

	    let options = {
		title: "Menu",
		width: 50,
		height: 100
	    };

	    let {title,width,height} = options;
	</div>
	</details>	
		
	<details>
	<summary>
		<h4>
			<b>Какие способы работы с асинхронным кодом имеются?</b>
		</h4>
	</summary>
	<div>

	- ***callback*** - функция обратного вызова
	- ***Promise***
	- ***async/await*** - специальный синтаксис по работе с промисами
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Для чего нужны e.preventDefault() и e.stopPropagination?</b>
		</h4>
	</summary>
	<div>

	***event.preventDefault()*** - отмена обработки события по умолчанию
	***event.stopPropagination()*** - отключение всплытия событий в html, то есть отключение прослушки события родителей.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Как отслеживать и обрабатывать ошибки в JavaScript?</b>
		</h4>
	</summary>
	<div>

	Для этого существует ***специальная конструкция***:

	    try {
		// код
	    } catch (error) {
		// Код в этом блоке выполнится, если в блоке 
		// try произошла ошибка
	    } finally {
		// Код в этом блоке выполнится в любом случае
	    }

	Error содержит объект ошибки с подробной информацией.

	Links:
	- [СОБЕСЕДОВАНИЕ на FRONTEND разработчика JS CSS REACT VUE HTTP. Подготовка к собеседованию](https://youtu.be/gV6eobXisYU)

	</div>
	</details>
- ### Angular
	
[//]: # "Шаблон"
	
<details>
<summary>
	<h4>
		<b>Шаблон</b>
	</h4>
</summary>
<div>

</div>
</details>
