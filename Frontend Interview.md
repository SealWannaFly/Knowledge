## **Что такое Guards?**
***Guards*** - это сущность, которая помогает решать задачи связанные с доступом человека к странице.  Можно ли загрузить данный компонент?
Наследуется от специальных интерфесов, например, ***CanActivate***,  ***CanActivateChild***. Возвращает ***true*** или ***false***, также может вернуть в формате ***Promise*** и ***Observable***. 

Мы можем использовать в этих классах свои сервисы, что является плюсом.

## **Что такое Modules и что в них входит?**
***Module*** - это набор сущностей с директивой ***@NgModule***. Имеет ***imports*** - для других модулей, ***providers*** - другие сервисы, ***declarations*** - компоненты, директивы и пайпы модуля, ***exports*** - публичные сущности модуля, ***bootstrap*** - компонент, с которого необходимо начать загрузку модуля.

## **В чем отличие AngularJS и Angular?**
Первая разработка Google - AngularJS. Содержал в себе контроль, директивы и т.п. Потом появился Angular 2, который по сути не имеет общего ничего, кроме названия. Его перименовали просто в Angular с версиями 2, 3 и т.п. Из отличий в Angular используется TypeScript, а контроллеры, директивы и т.п. находятся внутри декоратора @Component, также поддержка ES6 синтаксиса и Angular CLI.

## **Что такое Component и зачем их использовать?**
***Component*** - базовый строительный блок приложения. Angular строится в виде дерева, где один компонент содержит внутри другие, образуя древовидную структуру. Компоненты определяются декоратором ***@Component*** с одним обязательным параметром ***template*** или ***templateUrl***, а также параметрами ***selector***, ***styleUrls*** и др. Компоненты должны принадлежать какому-либо модулю (параметр ***declarations***), чтобы Angular мог их отслеживать и использовать.

## **Какие обязательные параметры имеет @Component?**
Декоратор ***@Component*** обязательно ***должен иметь шабло***н, то есть ***template*** или ***templateUrl***. Selector не является оюязательным, потому что в тестах мы можем сами создавать host-компоненты, не содержащие селектор.

## **Чем отличается модуль от компонента?**
***Компоненты*** контролируют html отображение. ***Модуль*** же содежит в себе компоненты, сервисы и т.п., определяя то, что есть в приложении в целом. ***Компонет - строительный блок***, **Модуль - коробочка, хранящая в себе все составные части приложения.**

## **Что такое сервисы и зачем они нужны?**
***Сервисы*** являются классом, где мы храним все данные. Компоненты хранят только визуальное представление. Таким образом мы ***отделяем данные от визуального представления***. Сервисы не взаимодействуют с html, с событиями, а только работают с данными, оставясь достаточно гибкой. По большей части являются Singleton, но мы имеем возможность создавать несколько экземпляров. 

Сервисы за счет своей гибкости позволяют создавать сложные масштабируемые приложения.

## **Разница между *ngIf и [hidden]?**
Директива ****ngIf*** полностью убирает элемент из ***DOM-дерева***, а атрибут ***[hidden]*** просто визуально скрывает, добавляя ***display: none***.

****ngIf*** меняет html, а ***hidden*** не меняет html.

## **Разница между @Component и @Directive**
***Компоненты*** отвечают за визуальное отображение и создают структуру приложения, а ***директивы*** задают модели поведения внутри html, например, добавление классов, событий, стилей, но не создают своей структуры и работают в рамках компоненты, где задают шаблонное поведение.

***Компоненты создают структуру, внутри которой с помощью директивы мы задаем шаблонное поведение.***

## **Что делает @HostBinding(['class.valid']) isValid: boolean?**
Декоратор @HostBinding по большей части используется в директивах. Мы привязываем динамический класс с названием valid к переменной isValid. То есть если переменная true, то применится класс valid к элементу с соответствующей директивой.

## **Разница между структурной и атрибут директивой?**
***Структурные директивы*** могут менять шаблон, например, *ngIf и *ngFor.
В Angular такие директивы ***помечаются "звездочкой"*** - "\*". ***Атрибут-директивы*** добавляют поведение, но не меняют шаблон. Например, ngStyle и ngClass.

## **Что такое Observables?**
Это классы, которые реализуют соответсвующий паттерн проектирования. Активно используются благодаря встроенной библиотеке RxJS.

Некоторые объекты могут создавать уведомления, если мы на них подписываемся, то являемся Observer. Если уведомление появляется, то мы сразу же получаем его во все местах. За счет этого работает рективная система внутри Angular.

## **Что такое интерполяция?**
***Интерполяция*** - синтаксис, который позволяет выводить динамические данные в шаблон, например {{ index }}, то есть ***обозначает связку между шаблоном и фукцинальной частью компоненты***.

## **В чем разница между Promise и Observable?**
Оба класса работают с асинхронным кодом и обрабатывают по сути результат. Promise заранее нельзя отменить, работает всегда с одним событием, то есть для каждого создаем свой Promise. Promise в любом случае будет выполнен, даже если нет никаких подписок (блок then), а Observable не выполнит асинхронный код, если нет подписчиков.

Мы можем подписываться и отписываться от потоков, применять операторы, а у Promise такого нет.

## **Разница между constructor и ngOnInit?**
***Конструктор*** приходит из ES6 и вызывается при создании экземпляра класса, это первый этап взаимодействия. Angular же сам работает с конструктором и создает проверки и другие нужные ему вещи, подготавливая компонент к работе. Мы туда инжектируем сервисы и сущности.

В ***жизненном цикле ngOnInit*** мы работаем с уже готовым к работе компонентом. Реализация его интерфейса является хорошей практикой для поддержки корректной работы. Например, в тестах иначе возникнут сложности.

## **Что такое реактивное программирование в Angular?**
***Реактивное программирование*** - это программирование с асинхронными потоками данных. В основном работают со встроенной ***библиотекой RxJS***, хотя имеются и другие способы, такие как ***EventEmitter*** (внутри тоже содержит RxJS). 

***RxJS*** позволяет работать с асинхронными потоками данных, которые в ядре содержат Observables. Позволяет работать с множеством операторов, которые позволяют изменять, фильтровать и т.д.

## **Зачем использовать spy в тестах?**
Angualr для тестирования использует фреймворк Jasmine, в котором есть эта функция spy.

Функция позволяет шпионить за методами, возвращая мок-данные вместо реального обращения к backend, а также отслеживать и собирать статистику. Это позволяет создавать универсальные тесты.

## **Что такое TestBed?**
Высокоуровневый фреймворк внутри Angular, позволяющий корректно тестировать и настраивать окружение. Мы можем создавать свои компоненты и т.п., подготавливаясь к интеграционному тестированию. ***Это набор инструментов, позволяющий реализовывать интеграционное тестирование***.

## **Что такое Protractor?**
Это фреймворк предназначенный для end-to-end тестирования. Это программа для node.js, которая запускает тесты в реальном браузере и отображает информацию о действиях пользователя.

## **Как реализовать Resize элементов?**
Добавлением 
`@HostListener('window:resize', ['$event'])
  onResize(event){
    //do something
  }`             
  AddEventListener не подходит для Angular. Встроенный декоратор @HostListener поддерживает глобальные window, document и body.

$event передаваемую в функцию ниже переменую.

## **Что такое AOT?**
***Ahead-of-time compiler*** - концепт, позволяющий заранее компилировать  структуру шаблона, потому что браузер не знаком с директивами и т.п. AOT заранее подготавливает структуру шаблона, получая более оптимизированное приложение. В проде ng build --prod используется по умолчанию.

Приложения быстрее запускаются, Angular заранее убирает неиспользуемые элементы, а также сам компилятор. В Dev версии присутсвует в клиентской версии, а на проде его отсутсвие уменьшает вес сборки.

Позволяет заранее подготовить Angular-приложение для оптимизации.

## **Что такое ActivatedRoute?**
 ***ActivatedRoute*** - это интерфейс или класс, который мы можем инжектировать в наш компонент и сервис, чтобы получить доступ к текущему активному роуту, например, получить QueryParams с реактивностью или же статику через snapshot.

## **Что такое динамические компоненты?**
***Динамические компоненты*** - это компоненты, положение которых заранее не определено в приложении. Они зарегестрированы, определены, но в шаблоне не используются. Мы можем их динамичсеки добавлять в DOM.

## **Какие функции несет в себе RxJS?**
***RxJS*** - это библиотека, которая позволяет нам работать с асинхронным кодом, а также преврашать его в Observables. 

Мы можем превращать как статитку, так и асинхронный код в Observables и работать с ним, как с асинхронным. Несет функционал создания таких потоков данных. Может помогать перебирать массив поэтапно, маппить, фильтровать, приводить к единому значению через reduce, создавать композицию из потоков.

## **Как передавать параметры в Pipe?**
Мы можем передавать их последовательно ***через символ ":"***, а в самом Pipe мы можем получать их со 2ого по N. Первый параметр всегада значение.

## **Какие типы binding существуют?**
- ***[disabled]*** - атрибуты (из компонента в шаблон)
- ***{{title}}*** - интерполяция (из компонента в шаблон)
- ***(mousedown)*** - события (из шаблона в компонент)
- ***[(email)]*** - 2 way binding (в обе стороны - любое изменение в модели приводят к изменению шаблона и обратно) 

## **Что такое life cycle hooks?**
***Life cycle hooks*** - ловушки жизненного цикла компоненты:
- ***constructor*** - как бы относится, но это из нативного языка
- ***ngOnChanges*** - каждое изменение Input свойства (SimpleChanges)
- ***ngOnInit*** - один раз после инициализации
- ***ngDoCheck*** - начало механизма ChangeDetection
- ***ngAfterContentInit (Component Only)*** - когда данные внутри компоненты получены
- ***ngAfterContentChecked (Component Only)*** - когда ChangeDetection проверил контент
- ***ngAfterViewInit (Component Only)*** - вызывается после выше. Готов отображение к работе
- ***ngAfterViewChecked (Component Only)*** - вызывается после выше. После СhangeDetection для отображения
- ***ngOnDestroy*** - вызывается перед уничтожение, в основном для отписок

## **Можно ли использовать jQuery?**
Да, это возможно, если нам нужен какой-то плагин, доступный только на нем. Установка через npm, в angular.json подключаем. А declare var $ нужен, чтобы TypeScript не ругался.

## **Что такое Interceptors?**
***Interceptor*** - это классы реализующие интерфейс, позволяющие перехватывать любые асинхронные запросы и, например, добавлять Header.

Это удобно, потому что можно использовать свои сервисы и обрабатывать ошибки.

## **Что делает метод detectChanges в тестах?**
detectChanges вручную вызвывает механизм ChangesDetection, потому что мы меняем переменные компоненты. 

##  ***Почему нужно использовать Renderer 2?***
***Renderer 2*** - дополнительный слой абстракции, который работает с DOM. Angular может использоваться не только в браузере, но и в мобильных приложения, web-workers 

*Web Workers это механизм, который позволяет скрипту выполняться в фоновом потоке, который отделен от основного потока веб-приложения*.

При использовании вне браузера обращения напрямую к DOM будут выдавать ошибку. ***Renderer 2*** позволяет писать один кода, работающий везде, делая код универсальным.

##  ***Зачем нужен Zone.js?***
Задача библиотеки Zone.js заключается в создании собственных оболочек вокруг асинхронных операций и функций в приложении для повышения удобства наблюдения. Сервис ngZone является оберткой вокруг Zone.js и реализует механизм ChangeDetection. Это повышает точность управления приложением, так как мы получаем информацию о последовательности завершенных операций и функций.

##  ***Что делает Just-in-time Compiler?***
***Just-in-time Compiler*** запускается в момент старта приложения, пересобирает и компилирует части кода на лету. Он имеет доступ к ОЗУ, где хранится текущая информация о приложении, что позволяет ему быстро и эффективно отображать результат в браузере. Все свои функции преобразования кода в машинный он ***делает до старта программы***.

##  ***Какие есть стратегии загрузки модулей?***
Angular позволяет нам создавать несколько модулей для формирования приложения.

Для оптимизации зачастую грузить все модули не обязательно.

Lazy loading - загрузка модулей по требованию. 
Нам доступны 3 различных стратегии загрузки модулей:
- По умолчанию (нет никакой ленивой загрузки)
- Lazy loading - загрузка модуля по требованию
- Preload - загрузка в фоне остальных модулей после основной части

Мы можем настраивать стратегии для каждого рута, а также создавать свои стратегии, наследуясь от базового класса.

##  ***Что такое Incremental DOM и отличие от Virtual DOM?***
***Incremental DOM*** используется в Angular, а Virtual DOM в React.
***Incremental DOM*** - концепт, при котором скомпилированный код компонентов составляет DOM-дерево, которое обновляется только в тех местах, где обновились данные.
***Virtual DOM*** - концепт, при котором каждый компонент создает свое DOM-дерево в процессе рендеринга. После происходит сравнение старого и нового, применяя только измененные участки.

##  ***Зачем нужен процесс компиляции?***
Компиляция - процесс преобразования специфического синтаксиса в понятный браузеру набор инструкций.

##  ***Разница между pure и impure Pipe?***
По умолчанию все pure, то есть обновляют свое значение только при изменении входных параметров функции transform.
Inpure Pipe обновляется всегда, когда срабатывает механизм Change Detection. Например, для async это нужно, чтобы работать с динамикой.

##  ***Разница между BehaviorSubject и Observable?***
***Observable*** позволяет нам подписываться на потоки данных и работать с ними.
***BehaviorSubject***, как и любой ***Subject***, позволяет создавать потоки, добавлять новые элементы потоков (***next***), а также подписываться на них. ***BehaviorSubject*** принимает начальное значение в конструкторе.

##  ***Как следить за изменением входящих свойств?***
Мы можем следить за изменением входящих свойств с помощью механизма ChangeDetection и ***ловушки жизненного цикла ngOnChanges***, где мы получаем changes: SimpleChanges.
Также можно использовать ***сеттеры***, в которых будем следить за изменениями.

##  ***Что такое Tree Shaking?***
***Tree Shaking*** - концепция, позволяющая существенно сократить размер bundle. Это доступно в webpack по умолчанию. Так как мы используем export с именем ,то мы избавляемся от всех не используемых элементов сторонних библиотек.

Link:
- [# Angular 40 вопросов для собеседования](https://youtu.be/rc3E4tplFCU)

## **Change Detection**
В Angular есть два варианта работы алгоритма отслеживания изменений:
\- OnPush
\- Default (используется по умолчанию)

Алгоритм задается в свойстве changeDetection объекта конфигурации декоратора ***@Component*** и указывается для каждого компонента отдельно.

Angular по  умолчанию  использует ***ChangeDetectionStrategy.Default***:
Если что-то меняется в результате *пользовательских событий*, *таймеров* (_setTimeout_  или _setInterval_), *промисов*, *XMLHttpRequest*  и *т.п*., обнаружение будет запускаться по всем компонентам.

*Ключевую роль здесь играет библиотека `zone.js`. В Angular с ее помощью все приложение разделяется на секторы, каждый из которых запоминает контекст асинхронного выполнения. Такой подход после завершения асинхронной операции позволяет запустить механизм отслеживания изменений в нужном секторе.*

*Когда происходит асинхронное событие, Angular запускает обнаружение изменений в своем самом верхнем **_ViewRef_**, который после запуска обнаружения изменений сам запускает обнаружение изменений для своих дочерних представлений (метод **_detectChanges_**).*

Запуск механизма **ChangeDetection** в родительском компоненте автоматически инициирует запуск механизма во всех дочерних компонентах.

Этот цикл называется грязной проверкой (**_dirty checking_**). Суть проверки заключается в том, что Angular сравнивает новые значения со старыми и обновляет представление если они не равны.

**ChangeDetectionStrategy.OnPush**  альтернативная стратегия, которая запускается только в момент создания компонента (стадия жизненного цикла **_OnChanges_**) и делает компонент зависимым от **_@Input_**  параметров, и будет проверяться только при условиях:

 - **Изменилась ссылка input параметра**
Установив OnPush стратегию, мы как бы подписываем договор с Angular, который обязывает нас работать с иммутабельными объектами или наблюдаемыми (observables).<br/><br/>
*Неизменяемым (англ. immutable) называется объект, состояние которого не может быть изменено после создания. Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится.*<br/><br/>
Речь не идет о глубоком копировании: если объект имеет вложенную структуру, то все вложенные объекты, не подвергшиеся модификации, будут переиспользованы.<br/><br/>
Иммутабельность сильно упрощает нам задачу: вместо того, чтобы сравнивать значение каждого поля каждого вложенного в ***state*** объекта с соответствующим значением из ***nextState***, можно просто сравнивать ссылки на соответствующие объекты и отсеивать таким образом целые вложенные ветки сравнений.<br/><br/>
Преимущество работы с иммутабельными данными в контексте обнаружения изменений в том, что Angular выполняет простую проверку по ссылке, чтобы решить, следует ли проверять представление. Это намного быстрее чем глубокое сравнение объектов.<br/><br/>
То есть если мы изменим свойство объекта, то ссылка на объект останется той же, и проверка изменений не начнется, нужно именно изменить ссылку на объект.<br/><br/>
Link: [Иммутабельность](https://habr.com/ru/company/devexpress/blog/302118/)

 - **_Событие внутри компонента или его потомка_**
Компонент может иметь внутреннее состояние, которое обновляется, когда возникает событие от самого компонента или его потомков.<br/><br/>
Это работает не со всеми асинхронными событиями, а **_только с событиями DOM_**.

 - **_Ручной запуск обнаружения изменений_**
Angular предоставляет нам три метода для самостоятельного запуска механизма обнаружения изменений:

     - **detectChanges()** запускает обнаружение изменений в самом компоненте и его потомках.

   - **ApplicationRef.tick()** запускает обнаружение изменений во всем приложении.

   - **markForCheck()** **не запускает** обнаружение изменений. Он помечает компонент и всех его родителей, что они должны быть
   проверены в текущем или следующем цикле обнаружения изменений.

 - **_Async pipe_** Без использования **_| async_**  изменения отображаться не будут, так как не происходит ни одно из условий выше.<br/><br/>
*Async* пайп подписывается на наблюдаемый объект или промис и возвращает последнее отданное им значение. Когда приходит новое значение, async пайп отмечает компонент как необходимый к проверке.

- **_OnPush_** **_и шаблонные переменные_**
Если мы определяем input параметр через ***@ContentChild*** внутри кода, а не шаблона, то Angular не узнает, что мы обновили свойство в компоненте. Только определив input параметр в шаблоне, Angular поймет, что это свойство нужно проверить в следующем цикле обнаружения изменении, создав **updateRenderer()** функцию, которая отслеживает изменения значений параметров в каждом цикле обнаружения изменений.<br/><br/>
Можно решить с помощью создания сеттера и вызова **markForCheck****()**

### **_Сервис_** **_ChangeDetectorRef_**
Основные методы сервиса:
  - ***detach()*** - полностью отключает механизм ChangeDetection;
  - ***detectChanges()*** - принудительно запускает механизм отслеживания изменений;
  - ***reattach()*** - используется после вызова detach() для активации механизма ChangeDetection.

Действие всех трех методов распространяется только на тот компонент, в пределах которого вызываются эти методы.

Links:
+ [https://habr.com/ru/company/infopulse/blog/358860/](https://habr.com/ru/company/infopulse/blog/358860/)
+ [https://angdev.ru/doc/angular-change-detection/](https://angdev.ru/doc/angular-change-detection/)
+ [https://dev-gang.ru/article/vse-czto-vam-nuzhno-znat-o-change-detection-v-angular-s6rpx73job/](https://dev-gang.ru/article/vse-czto-vam-nuzhno-znat-o-change-detection-v-angular-s6rpx73job/) (Что-то на техническом)

## **SOLID**
***Основные плюсы***:
- Инкапсуляция отдельных сущностей 
- Прозрачная организация архитектуры

***Принципы***:
1. **Единой ответственности** (*Single Responsibility*)
У модуля должна быть только одна причина для изменения. Класс должен отвечать за что-то одно. <br/><br/>
Организация кода таким образом, чтобы в случае изменения задействовать наименьшее количество модулей(классов).<br/><br/>
Принцип позволяет:
   - Декомпозировать на независимые модули
   - Уменьшать количество связей между модулями
   - Изменять меньше классов при расширении функционала
   - Ограничивать влияние изменений на несвязные сущности

2. **Открытости и закрытости** (*Open-Closed*)
Модуль открыт для расширения и закрыт для изменения. Разработка устойчивого к изменениям приложения. Небольшое изменение класса не должно затрагивать большое количество связанных модулей.<br/><br/>
Принцип позволяет:
   - Проектировать модули, выполняющие только одну задачу
   - Вводить абстракции, через которые будет осуществляться связь сущностей
   - Рассширять имплементацию и защищать ее от изменений
   - Выносить место взаимодействия модулей в отдельную прозрачную сущность

3. **Подстановки Барбары Лисков** (*Liskov Substitution*)
Подклассы могут служить заменой своим суперклассам. Функции, использующие базовый тип должны уметь работать с его подтипами. Проектирование логики таким образом, чтобы классы-наследники могли  корректно использоваться вместо классов-родителей. <br/><br/>
*В общем случае, лучше использовать общий интерфейс, а не наследование, чтобы избежать излишних проверок.*<br/><br/>
Принцип позволяет:
   - Выявлять проблемные абстракции и скрытые связи между сущностями
   - Делать поведение модулей предсказуемым
   - Вводить ограничение на наследование, чтобы потомки не противоречили базовому поведению

4. **Разделение интерфейсов** (*Interface Segregation*)
Сущности не должны зависеть от интерфейсов, которые они не используют. Чтобы при наследовани потомки не получали неиспользуемый функционал от предка, для этого интерфейсы нужно декомпозировать.<br/><br/>
Принцип позволяет:
   - Уменьшать количество зависимостей между модулями
   - Избавляться от ненужной функциональности при наследовании
   - Затрагивать только нужные части, а не все зависящие модули, при изменении
   - Декомпозировать, то есть разделять сущности

5. **Инверсия зависимостей** (*Dependency Inversion*)
Модули высших уровней не должны зависеть от модулей низких уровней, а должны зависеть от абстракций. Абстракции же не должны зависеть от деталей, а, наоборот, детали должны зависеть от абстракций.<br/><br/>
Верхнеуровневые сущности не должны зависеть от нижнеуровневых реализация, а любые зависимости лучше всего выносить в абстракции, то есть инкапсулировать в отдельных сущностях. <br/><br/>
Принцип позволяет:
   - Уменьшать количество зависимостей между модулями, повышая простоту чтения, понимания и тестирования

Links:
+ [Короткое видео](https://youtu.be/A6wEkG4B38E)
## **EventLoop**
JavaScript - однопоточный язык. Как выполняется асинхронный код? Для этого нужно рассмотреть цикл событий (EventLoop).<br/><br/>
EventLoop - это бесконечный цикл, который ожидает задачи, выполнят их и снова ожидвет поступление новых задач.<br/><br/>
*А как же тогда работает setTimeout(), слушатели событий и другие асинхронные операции? Эта функция на самом деле не принадлежит спецификации JavaScript, а предоставляется браузером (Web Api). Она вызывается у глобального объекта window. Функция принимает в себя первым параметром функцию-callback, а вторым параметром время ожидания в миллисекундах. 
Callback можно передавать в виде анонимной функции, можно по ссылке(без скобочек) уже имеющуюся.* <br/><br/>
Основные игроки:
- Стек вызова (Call Stack)
- Очередь задач (Callback queue)
- Web Apis
- Event Loop
<br/><br/>
Link: [Сервис для демонстрации работы](http://latentflip.com/loupe/)<br/><br/>

Синхронные операции добавляются в ***стек вызова*** и выполняются. Когда движок JS доходит до ***асинхронного кода***, то он регистрирует функцию-callback и вызывает функцию из нужного Web Api. После выполнения кода на стороне Web Api функция-callback попадает в ***очередь задач*** , где ждет до того момента, пока стек вызова не останется пустым. Когда ***стек вызова*** опустеет, самая старая задача из очереди задач переместится в ***стек вызова***.<br/><br/>
*Вопрос собеседований про setTimeout(function, 0) связан с тем, что результат работы асинхронной функции будет вызываться после всего имеющегося синхронного кода в стеке вызова, то есть пока стек вызова не опустеет.*<br/><br/>
Links:
- [Наглядная выжимка](https://youtu.be/377qAu37OTE)
- [Владилен Минин](https://youtu.be/vIZs5tH-HGQ)
## **RxJS**
Библиотека позволяет работать с синхронными и асинхронными функциями в удобном формате.

На потоки подписываемся с помощью ***.subscribe(() => {})***. Имеет 3 метода:
- ***next*** функция для обработки следующего значения
- ***error*** функция для обработки ошибок
- ***complete*** функция обработки завершения потока

Их можно передавать в виде объекта с соответсвующими ключами.
Отписываемся с помощью метода ***unsubscribe***

Классы:
- **Observable** наблюдатель по соответствующему паттерну проектирования. В конструкторе можем указывать через ***next*** передаваемого объекта observer следющие значения
- **Subject** тот же Observable, но имеет возможность добавлять новые элементы в поток вне конструктора. Стартового значения не имеет
- **BehaviorSubject** тот же Subject, только имеет в конструкторе стартовое значение. При подписке передает последнее значение
- **ReplaySubject** тот же Subject, но запоминает прошлые значения и воспроизводит их. Можно в конструкторе указать размер буфера, то есть количество запоминаемых событий

Операторы применяются последовательно внутри ***.pipe()***:
- **scan((accumulator, value) => {}, seed)** работает по типу reduce метода массивов. Seed - это начальное значение накопителя
- **reduce** обрабатывает завершенный поток
- ***map*** модифицирует поток
- **tap** получает каждое значение потока, но никак не влияет на данные
- **filter** фильтрует данные по заданному правилу
- **take** ограничивает поток заданным количеством элементов
- **takeLast** накапливает заданное количество последних значений и возвращает их
- **takeWhile** ограничивает поток по условию
- **switchMap** позволяет изменить текущий поток на другой поток
- [огромное количество других операторов](https://rxjs.dev/api)

Создание потоков:
- **of(1,2,3,4)** создает поток из последовательности аргументов
- **from([1,2,3,4])** создает поток из массива элементов
- ***fromEvent(selector, eventName)*** создает поток для событий
- **interval(period)** создает поток чисел счетчика через период
- **timer(dueTime)** аналогично setTimeout только с возможностью подписки
- **range(start, numberOfElements)** создает поток из N элементов от начального

Link:
- [Владилен Минин](https://youtu.be/gCwSVQO_PtY)
