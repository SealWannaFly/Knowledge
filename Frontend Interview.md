## **Change Detection**
В Angular есть два варианта работы алгоритма отслеживания изменений:
\- OnPush
\- Default (используется по умолчанию)

Алгоритм задается в свойстве changeDetection объекта конфигурации декоратора ***@Component*** и указывается для каждого компонента отдельно.

Angular по  умолчанию  использует ***ChangeDetectionStrategy.Default***:
Если что-то меняется в результате *пользовательских событий*, *таймеров* (_setTimeout_  или _setInterval_), *промисов*, *XMLHttpRequest*  и *т.п*., обнаружение будет запускаться по всем компонентам.

*Ключевую роль здесь играет библиотека `zone.js`. В Angular с ее помощью все приложение разделяется на секторы, каждый из которых запоминает контекст асинхронного выполнения. Такой подход после завершения асинхронной операции позволяет запустить механизм отслеживания изменений в нужном секторе.*

*Когда происходит асинхронное событие, Angular запускает обнаружение изменений в своем самом верхнем **_ViewRef_**, который после запуска обнаружения изменений сам запускает обнаружение изменений для своих дочерних представлений (метод **_detectChanges_**).*

Запуск механизма **ChangeDetection** в родительском компоненте автоматически инициирует запуск механизма во всех дочерних компонентах.

Этот цикл называется грязной проверкой (**_dirty checking_**). Суть проверки заключается в том, что Angular сравнивает новые значения со старыми и обновляет представление если они не равны.

**ChangeDetectionStrategy.OnPush**  альтернативная стратегия, которая запускается только в момент создания компонента (стадия жизненного цикла **_OnChanges_**) и делает компонент зависимым от **_@Input_**  параметров, и будет проверяться только при условиях:

 - **Изменилась ссылка input параметра**
Установив OnPush стратегию, мы как бы подписываем договор с Angular, который обязывает нас работать с иммутабельными объектами или наблюдаемыми (observables).﻿﻿

*Неизменяемым (англ. immutable) называется объект, состояние которого не может быть изменено после создания. Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится.*

Речь не идет о глубоком копировании: если объект имеет вложенную структуру, то все вложенные объекты, не подвергшиеся модификации, будут переиспользованы.

Иммутабельность сильно упрощает нам задачу: вместо того, чтобы сравнивать значение каждого поля каждого вложенного в ***state*** объекта с соответствующим значением из ***nextState***, можно просто сравнивать ссылки на соответствующие объекты и отсеивать таким образом целые вложенные ветки сравнений.

Преимущество работы с иммутабельными данными в контексте обнаружения изменений в том, что Angular выполняет простую проверку по ссылке, чтобы решить, следует ли проверять представление. Это намного быстрее чем глубокое сравнение объектов.

То есть если мы изменим свойство объекта, то ссылка на объект останется той же, и проверка изменений не начнется, нужно именно изменить ссылку на объект.

Link: [Иммутабельность](https://habr.com/ru/company/devexpress/blog/302118/)
 - **_Событие внутри компонента или его потомка_**
Компонент может иметь внутреннее состояние, которое обновляется, когда возникает событие от самого компонента или его потомков.
</br>
Это работает не со всеми асинхронными событиями, а **_только с событиями DOM_**.

 - **_Ручной запуск обнаружения изменений_**
Angular предоставляет нам три метода для самостоятельного запуска механизма обнаружения изменений:

     - **detectChanges()** запускает обнаружение изменений в самом компоненте и его потомках.

   - **ApplicationRef.tick()** **запускает обнаружение изменений во всем приложении.**

   - **markForCheck()** **не запускает** обнаружение изменений. Он помечает компонент и всех его родителей, что они должны быть
   проверены в текущем или следующем цикле обнаружения изменений.

 - **_Async pipe_** Без использования **_| async_**  изменения отображаться не будут, так как не происходит ни одно из условий выше.

*Async* пайп подписывается на наблюдаемый объект или промис и возвращает последнее отданное им значение. Когда приходит новое значение, async пайп отмечает компонент как необходимый к проверке.

- **_OnPush_** **_и шаблонные переменные_**
Если мы определяем input параметр через ***@ContentChild*** внутри кода, а не шаблона, то Angular не узнает, что мы обновили свойство в компоненте. Только определив input параметр в шаблоне, Angular поймет, что это свойство нужно проверить в следующем цикле обнаружения изменении, создав **updateRenderer()** функцию, которая отслеживает изменения значений параметров в каждом цикле обнаружения изменений.

Можно решить с помощью создания сеттера и вызова **markForCheck****()**

### **_Сервис_** **_ChangeDetectorRef_**
Основные методы сервиса:
  - ***detach()*** - полностью отключает механизм ChangeDetection;
  - ***detectChanges()*** - принудительно запускает механизм отслеживания изменений;
  - ***reattach()*** - используется после вызова detach() для активации механизма ChangeDetection.

Действие всех трех методов распространяется только на тот компонент, в пределах которого вызываются эти методы.

Links:
+ [https://habr.com/ru/company/infopulse/blog/358860/](https://habr.com/ru/company/infopulse/blog/358860/)
+ [https://angdev.ru/doc/angular-change-detection/](https://angdev.ru/doc/angular-change-detection/)
+ [https://dev-gang.ru/article/vse-czto-vam-nuzhno-znat-o-change-detection-v-angular-s6rpx73job/](https://dev-gang.ru/article/vse-czto-vam-nuzhno-znat-o-change-detection-v-angular-s6rpx73job/) (Что-то на техническом)

