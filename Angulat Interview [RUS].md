## Вопросы для подготовки к собеседованию

### Меню :computer:	
- ### Общий блок :disguised_face:		
	
	[//]: # "Как устроен браузер?" 	

	<details>
	<summary>
		<h4>
			<b>Как устроен браузер?</b> :globe_with_meridians:
		</h4>
	</summary>
	<div>
	<img src="https://habrastorage.org/webt/dl/fr/hh/dlfrhh43eqb66arhgeic_h6e_8c.png" alt="Браузер под капотом"/>

	- ***User Interface*** — это все что видит пользователь: адресная строка, кнопки вперед/назад, меню, закладки — за исключением области, где отображается сайт.  
	- ***Browser Engine*** отвечает за взаимодействие между User Interface и Rendering Engine. Например, клик по кнопке назад должен сказать компоненте RE, что нужно отрисовать предыдущее состояние.
	- ***Rendering Engine*** отвечает за отображение веб-страницы. В зависимости от типа файла, эта компонента может парсить и рендерить как HTML/XML и CSS, так и PDF.  
	- ***Network*** выполняет xhr запросы за ресурсами, и в целом, общение браузера с остальным интернетом происходит через эту компоненту, включая проксирование, кэширование и так далее.  
	- ***JS Engine*** место, где парсится и исполняется js код.  
	- ***UI Backend*** используется чтобы рисовать стандартные компоненты типа чекбоксов, инпутов, кнопок.  
	- ***Data Persistence*** отвечает за хранение локальных данных, например в куках, SessionStorage, indexDB и так далее.

	Link:
	- [Рендеринг веб сайтов 101](https://habr.com/ru/post/484900/)
	</div>
	</details>
	
	[//]: # "Как рендерится WEB-страница?"

	<details>
	<summary>
		<h4>
			<b>Как рендерится WEB-страница?</b>
		</h4>
	</summary>
	<div>
	<img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000545/images/hpbn_1001.png" alt="Общая схема"/>

	Последовательность работы браузера при отображении документа:
	 1. ***Формируется DOM (Document Object Model)*** из полученного от сервера HTML-документа
	 2. ***Формируется CSSOM (CSS Object Model)*** путем загрузки и распознавания стилей
	 3. ***Формируется дерево рендеринга (Render Tree)*** — набор объектов рендеринга (Webkit использует термин «renderer», или «render object», а Gecko — «frame») на основе DOM и CSSOM Render tree описывает визуальное представление DOM. <br/><br/> *Render tree дублирует структуру DOM, но сюда не попадают невидимые элементы (например — `<head>`, или элементы со стилем `display:none;`). Каждая строка текста будет представлена как отдельный renderer. Каждый объект рендеринга содержит соответствующий ему объект DOM (или блок текста), и рассчитанный для этого объекта стиль*

	 4. ***Рассчитывается положение на странице (layout)*** для каждого элемента render tree. Браузеры используют поточный метод (flow), при котором в большинстве случаев достаточно одного прохода для размещения всех элементов (для таблиц проходов требуется больше)

	 5. ***Отрисовка браузером страницы пользователю (painting)***

	В процессе взаимодействия пользователя со страницей, а также выполнения скриптов, она меняется, что требует повторного выполнения некоторых из вышеперечисленных операций.

	***Repaint (Restyle)*** - отрисовка элемента заново с новым стилем в случае изменения стилей элемента, не влияющих на его размеры и положение на странице (например, `background-color`, `border-color`, `visibility`).

	***Reflow (Relayout)*** - перерасчет положения элемента, если изменения затрагивают содержимое, структуру документа, положение элементов. Причинами таких изменений обычно являются:
	-   Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов);
	-   Изменение содержимого, в т.ч. текста в полях форм;
	-   Расчёт или изменение CSS-свойств;
	-   Добавление, удаление таблиц стилей;
	-   Манипуляции с атрибутом «`class`»;
	-   Манипуляции с окном браузера — изменения размеров, прокрутка;
	-   Активация псевдо-классов (например,  `:hover`)

	**Оптимизация со стороны браузера**
	Браузеры по возможности ***локализуют repaint и reflow*** в пределах элементов, подвергнувшимися изменению. Например, изменение размеров абсолютно или фиксировано спозиционированного элемента затронет только сам элемент и его потомков, в то время как изменение статично спозиционированного — повлечет reflow всех элементов, следующих за ним.  

	Во время выполнения JavaScript браузеры кэшируют вносимые изменения, и применяют их ***в один проход*** по завершению работы блока кода. Но бращение к свойствам элементов вызовет ***принудительный reflow***.

	</div>
	</details>
	
	[//]: # "Практические советы по оптимизации"

	<details>
	<summary>
		<h4>
			<b>Практические советы по оптимизации</b> :hammer_and_wrench:
		</h4>
	</summary>
	<div>
		
	Советы, которые пригодятся при создании эффективного фронтенда  
		
	-   Пишите валидный HTML и CSS, с указанием кодировки. Стили лучше включать в  `<head>`, а скрипты — в конце  `<body>`.
	-   Стремитесь упрощать и оптимизировать селекторы CSS. Чем меньше вложенность — тем лучше. По эффективности обработки селекторы можно расположить в следующем порядке (начиная с наиболее быстрого):  
		
	    1.  Идентификатор:  `#id`
	    2.  Класс:  `.class`
	    3.  Тэг:  `div`
	    4.  Соседний селектор:  `a + i`
	    5.  Дочерний селектор:  `ul > li`
	    6.  Универсальный селектор:  `*`
	    7.  Селектор атрибутов:  `input[type="text"]`
	    8.  Всевдоэлементы и псевдоклассы:  `a:hover`

		
	Следует помнить, что браузер обрабатывает селекторы справа налево, поэтому в качестве ключевого (крайнего правого) селектора лучше использовать наиболее эффективные — идентификатор и класс.  

		    ```
		    div * {...} // плохо
		    .list li {...} // плохо
		    .list-item {...} // хорошо
		    #list .list-item {...} // хорошо
		    ```

	-   В скриптах минимизируйте любую работу с DOM. Кэшируйте всё: свойства, объекты, если подразумевается повторное их использование. При сложных манипуляциях разумно работать с «offline» элементом (т.е. который находится не в DOM, а в памяти), с последующим помещением его в DOM.  
	-   Для изменения стилей элементов лучше модифицировать только атрибут «`class`», и как можно глубже в дереве DOM, это и более грамотно с точки зрения разработки и поддержки (отделение логики от представления), и менее затратно для браузера.
	-   Анимировать желательно только абсолютно и фиксировано спозиционированные элементы.
	-   Можно отключать сложные :hover анимации во время скроллинга (например, добавляя к body класс «`no-hover`»).

	Links:
	- [Рендеринг WEB-страницы: что об этом должен знать front-end разработчик](https://habr.com/ru/post/224187/)
	- [Рендеринг веб сайтов 101](https://habr.com/ru/post/484900/)
	- [Техническое описание  с браузерными инструментами](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ru)
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое HTTP?</b> :dna:	
		</h4>
	</summary>
	<div>
		<img src="https://www.clickminded.com/wp-content/uploads/client-and-server-communication-protocols.png" alt="HTTP"/>
		
	***HTTP*** - протокол прикладного уровня, предназначенный для передачи данных по сети. 
	</div>
	</details>	
			
	<details>
	<summary>
		<h4>
			<b>Из чего состоит HTTP запрос?</b>
		</h4>
	</summary>
	<div>
	Состав:
		
	- ***строка запроса (Request Line)*** - метод передачи, url и версию hhtp
	- ***заголовки (Message Headers)*** - дополнительные сведения
	- ***\n*** - разделитель
	- ***тело сообщения (Entity Body)*** - может отсутсвовать, сами данные
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое websockets?</b> :telephone:	
		</h4>
	</summary>
	<div>
	
	***Websockets*** - протокол для взаимодействия в реальном времени. Участники устанавливают соединение и общаются до его завершения.
		
	</div>
	</details>
		
		
	<details>
	<summary>
		<h4>
			<b>Что такое Rest API?</b> :handshake:	
		</h4>
	</summary>
	<div>
	<img src="https://miro.medium.com/max/1400/1*f-4u01cDYiy6N5IRBktZnw.png" alt="Rest API"/>
		
	***Rest*** - один из самых популярных архитектурных подходов, который подразумевает взаимодействие клиент-сервер. Разделение разных операций CRUD через отдельные методы HTTP.
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Анализ CSS</b> 
		</h4>
	</summary>
	<div>
		Когда браузер отображает документ, он <b>должен совместить содержимое со стилями</b>. Этот процесс идёт в несколько этапов, о которых мы сейчас поговорим.

	Обобщенная версия (там все сложнее, и зависит от браузера):
	1.  Браузер получает HTML-страницу 
	2.  Преобразует  [HTML](https://developer.mozilla.org/ru/docs/Glossary/HTML)  в  [DOM](https://developer.mozilla.org/ru/docs/Glossary/DOM)  (_Document Object Model_).
	3.  Браузер загружает все ресурсы и описания, связанные с HTML-документом, например: встроенные картинки, видео ... и стили CSS! 
	4.  Браузер анализирует полученный CSS код, сортирует описанные там правила в зависимости от их селекторов и раскладывает их в различные «корзины»: элементы, классы, идентификаторы(ID) и т.п. Основываясь на найденных селекторах браузер понимает какие правила относятся к определённым «узлам» в DOM-дереве и применяет их по мере необходимости (этот промежуточный шаг называют «формированием дерева представления» или «формированием дерева рендеринга»)
	5.  Дерево представления (_render tree_) формируется в том порядке, в каком оно затем должно будет отображаться, когда все правила будут применены.
	6.  Затем происходит визуальное отображение контента на странице (этот этап называется «отрисовкой»)

		
	<img src="https://mdn.mozillademos.org/files/17080/Browser_simple_rendering_pipeline__ru.png" alt="Диаграмма"/>

		
	Если браузер встретит свойство, которое он не понимает, он просто-напросто проигнорирует его и двинется дальше. Он сделает так, если программист допустил опечатку или ошибку в свойстве или значении или если браузер не поддерживает какое-либо свойство или значение.

		
	Link:
	- [# Как работает CSS](https://developer.mozilla.org/ru/docs/Learn/CSS/First_steps/How_CSS_works)

		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Оптимизация CSS</b> :screwdriver:	
		</h4>
	</summary>
	<div>
	Деление на группы селекторов по эффективности обработки (начиная с более быстрого):
	<img src="https://webformyself.com/wp-content/uploads/2018/294/1.jpg" alt="Группы селекторов по эффективности обработки"/>
		
	Браузеры читают CSS <b>справа налево</b>. Самый правый селектор в составном селекторе известен как селектор key. Так, например, в #id .class > ul a, селектор key является a. 

	*Браузер сначала находит все элементы на странице, которые соответствуют селектору. Затем он находит все элементы ul на странице и фильтрует a до тех же элементов, которые являются потомками ul, и так далее, пока не достигнет крайнего левого селектора.*

	Поэтому чем короче селектор, тем лучше. Если возможно, убедитесь, что селектор key является классом или идентификатором, чтобы сохранить его быстрым и конкретным.

	***Качество важнее количества***

	Большая проблема просто наличия дорогих селекторов — их много. Примерами проблемы ***«раздувание стиля»*** являются сайты, которые импортируют целые фреймворки CSS, такие как Bootstrap или Foundation, при использовании менее 10% переданного CSS. Другой пример можно увидеть в старых, никогда не рефакторизованных проектах, чей CSS теперь больше похож на заросший сад, полный сорняков.

	Мало того, что большой файл CSS занимает больше времени для передачи (сеть является самым узким местом в производительности веб-сайта), они также занимают больше времени для синтаксического анализа. Помимо построения DOM из вашего HTML, браузеру необходимо построить CSSOM (объектную модель CSS), чтобы сравнить его с DOM и сопоставить селекторы.

	Итак, держите свои стили стройными и сухими, не включайте все и кухонную раковину, загружайте то, что вам нужно, и когда вам это нужно.

	Link:
	- [Оптимизация CSS: идентификаторы и другие мифы](https://webformyself.com/optimizaciya-css-identifikatory-i-drugie-mify/)
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Еще немного о Repaint и Reflow</b> :crayon:	
		</h4>
	</summary>
	<div>
		
	**Repaints and reflows**
	При загрузке страницы, если она не пустая, всегда выполняется, как минимум, по одному reflow и repaint. Далее эти события возникают в следующих случаях:  
	 - Часть дерева отображения нуждается в перерасчете, т. е. у какого-то узла изменились ширина, высота или координаты. Вызывается событие ***reflow***.  
	 - В результате изменений часть отображаемого контента должна обновиться. Речь идет, в первую очередь, о свойствах стилей: цвет фона, радиус и т. д. Вызывается событие ***repaint***.  

	***Если вызывается reflow, после него обязательно вызовется и repaint***. Но ***обратное неверно***: repaint может вызываться независимо от reflow.

	**Какие действия вызывают reflow и/или repaint**:
	**1) Добавление, обновление, удаление DOM-узла.** Потому что при этих событиях нужно перерасчитывать дерево отображения.  
	- ***Функции***:  
	  - insertAdjacentHTML()
	  - appendChild()
	  - insertBefore()
	  - removeChild()
	  - replaceChild()
	  - remove()
	  - append()/prepend()
	  - after()/before()
	  - replaceWith()  
		
	- ***Изменение свойств DOM-узла***:  
	  - innerHTML
	  - innerText
	  - width
	  - height
	  - offsetTop
	  - offsetLeft
	  - offsetWidth
	  - offsetHeight
	  - scrollTop/Left/Width/Height
	  - clientTop/Left/Width/Height  

	- ***Запрос свойств DOM-узла без его изменения***:  
	  - offsetTop
	  - offsetLeft
	  - offsetWidth
	  - offsetHeight
	  - scrollTop/Left/Width/Height
	  - clientTop/Left/Width/Height  

	Простой запрос некоторых свойств может вызвать reflow, к которым, в частности, относятся все офсет-свойства. 

	При запросе этих свойств браузеру нужно выполнить перекомпоновку незамедлительно, т. к. они должны возвращать актуальную информацию. Поэтому всякий раз, когда мы запрашиваем эти свойства, происходят reflow и repaint.

	**2) Скрытие DOM-узла** с помощью ***display: none*** (reflow и repaint) или ***visibility: hidden*** (только repaint, потому что нет геометрических изменений).  

	**3) Перемещение, анимация DOM-узла.**  
	Меняются координаты анимируемого узла дерева отображения, что может вызывать изменение размеров других узлов.  

	**4) Добавление/изменение CSS**    
	Если мы захотим изменить left, top,right,bottom,width,height css-свойства, это тоже вызовет reflow.  

	**5) Пользовательские действия**: изменение размеров окна (resize), изменение шрифта, прокрутка(scroll), drag and drop.  

	**6) Другое**  
	 - JS Scrolling_: 
	   - Скроллинг через скрипт и соответствующие ему свойства.  
	scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft, scrollTop, scrollWidth  
	-  Глобальные методы и события для объекта window:_  
	   - getComputedStyle(), scrollBy(), scrollTo(), scrollX, scrollY  
	- Работа с SVG

	 Link:
	 - [Repaints и reflows — и принципы работы event loop](https://habr.com/ru/company/dataart/blog/304934/)
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Свойство display - какие значения принимает и как они работают?</b> :desktop_computer:	
		</h4>
	</summary>
	<div>
		
	Основные значения:
		
	- ***none*** - элемент не показывается на экране
	- ***block*** - блочные элементы, располагаются друг над другом вертикально. Стремится расшириться на всю доступную ширину.
	- ***inline*** - элементы располагаются на одной строке последовательно. Ширина и высота определяются по содержимому, изменить их нельзя.
	- ***inline-block*** - элемент является строчным, но ему можно менять высоту и ширину.
	- ***flex*** - более сложный вариант
	- ***grid*** - более сложный вариант
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Какие бывают значения у свойства position?</b> :round_pushpin:	
		</h4>
	</summary>
	<div>
		
	Основные значения:
		
	- ***static*** - статическое позиционирование по умолчанию
	- ***relative*** - позиционирование сдвигаетс относительно его обычного положения. С помощью свойств top, left, right и bottom
	- ***absolute*** - позиционируется заново. Остальные элементы позиционируются так, будто его нет. Свойства top, left, right и bottom отсчитываются от ближайшего позиционированного родителя или же от всего документа, если нет родителя
	- ***fixed*** - похоже на absolute за исключением того, что fixed крепится к определенной части экрана и находится там даже с учетом прокрутки.
	- ***sticky*** - похож на fixed, но крепится внутри блока, а не документа
	</div>
	</details>

	<details>
	<summary>
		<h4>
			<b>Как отцентровать блок по горизонтали и вертикали?</b>
		</h4>
	</summary>
	<div>
		
	На данный момент самый простой способ:

	    display: flex;
	    justify-content: center; // по горизонтали
	    align-items: center; // по вертикали

	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что делает box-sizing: border-box?</b> :package:	
		</h4>
	</summary>
	<div>
		
	При использовании этого свойства ширина и высота будут ***включать в себя*** ***padding*** и ***border***, но не ***margin***.	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое Inline стили и какой у них приоритет?</b>
		</h4>
	</summary>
	<div>
		
	***Inline стили*** пишутся в html и имеют самый высокий приоритет.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое БЭМ?</b> 
		</h4>
	</summary>
	<div>
		
	***БЭМ*** - это методология ***Блок-Элемент-Модификатор***, которая подразумевает компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки, позволяющий легко и быстро разворачивать интерфейсы любой сложности и повторно использовать код.
	</div>
	</details>
	
	<details>
	<summary>
		<h4>
			<b>Что такое vh и vw?</b> :thinking:	
		</h4>
	</summary>
	<div>

	***vh*** - 1% от высоты окна браузера
	***vw*** - 1% от ширины окна браузера
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Из чего строится размер элемента?</b>
		</h4>
	</summary>
	<div>

	Размер элемента строится из:
		
	- ***размеров содержимого***
	- ***внутренних отступов***
	- ***рамки***
	- ***внешних отступов***

	</div>
	</details>
	
	<details>
	<summary>
		<h4>
			<b>За что отвечает z-index?</b> :ru:	
		</h4>
	</summary>
	<div>
		
	***z-index*** управляет вертикальным порядком расположения элементов, которые перекрываются. Z-index влияет на все элементы, где position не равно static. 
	Без заданного значения они появляются в том порядке, в котором заданы в DOM.	Без заданного значения они появляются в том порядке, в котором заданы в DOM.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое псевдоклассы и какие вы используете чаще всего?</b>
		</h4>
	</summary>
	<div>
		
	***Псевдоклассы*** описывают характеристики элементов, такие как динамическое состояние. Не отображаются в документе и не принадлежат DOM.

	Часто используемые: :focus, :checked и :hover
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Как увеличить в размере элемент, не сдвигая соседние?</b>
		</h4>
	</summary>
	<div>
	Используя свойство transform: scale() и другие. 
	</div>
	</details>
		
- ### Про JS :cat:	
	
	<details>
	<summary>
		<h4>
			<b>Типы данных в JS</b> :orangutan:	
		</h4>
	</summary>
	<div>
		
	***8 типов данных***:
	- ***null*** - примитивный тип
	- ***undefined*** - примитивный тип
	- ***boolean*** - примитивный тип 
	- ***number*** - примитивный тип
	- ***string*** - примитивный тип
	- ***object*** - простая структура данных
	- ***symbol*** - примитивный тип
	- ***bigint*** - примитивный тип

		
	Кавычки "", '' и `` - литералы, в которые мы можем вставлять динамические данные через ${}

	Оператор ***typeof*** возвращает тип данных  в виде строки.
	***Особенности typeof***:
	- ***typeof null - object***, хотя на самом деле Null
	- ***typeof function() {} - function***, хотя на самом деле Object
	- ***typeof NaN - number***, хотя значит дословно не число

		
	***Undefined*** - переменная не объявлена или объявлена через var без присвоенного значения. Void функции также возвращают undefined.
	***Null*** - отсутствие значение, мы ее обнулили сами.

	Приведение типов явное через обертки или неявное внутри функций.
	Есть всегда false значения ***'', 0, null, undefined, NaN, false***, а остальные значения дают true.
	***Оператор сложения*** определен для string, поэтому если первая переменная string, то приведение будет к строке.
	***Остальные математические операции*** будут приводить все переменные к number. Если не получится привести, то NaN.

	Сравнение ***==*** и ***===***
	- ***==*** сравнивает с приведением типов
	- ***===*** сравнивает без приведения типов

	Неоднозначные сравнения, потому что приведение в данном случае идет своим особенным алгоритмом:
	- ***console.log(false == '')*** - true
	- ***console.log(false == [])*** - true
	- ***console.log(false == {}***) - false <br/><br/>
	- ***console.log('' == 0)*** - true
	- ***console.log('' == [])*** - true
	- ***console.log('' == {})*** - false <br/><br/>
	- ***console.log(0 == [])*** - true
	- ***console.log(0 == {})*** - false
	- ***console.log(0 == null)*** - false
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Какими способами можно объявить переменную?</b> :right_anger_bubble:	
		</h4>
	</summary>
	<div>
		
		a = 5
		var b = 10
		let c = "let"
		const obj = {}
   
	Первые два способа создают переменную ***глобальной*** или же ***функциональной*** области видимости, но не имеют блочной. Такой способ ***является устаревшим***.
	`let` и `const` имеют ***блочную*** область видимости.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>В чем разница между null и undefined?</b> :hole:	
		</h4>
	</summary>
	<div>
		
	Оба обозначают пустое значение. 
	Если мы создаем переменную, но ***не инициализируем*** ее значение, то в нее помещается специальный маркер, отображающийся как ***undefined***.
	***null*** мы ***присваеваем самостоятельно***, что означает ничего или пусто, например, для очистки значения переменной. 
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Для чего нужны map, filter, reduce, forEach , каковы особенности использования?</b> :world_map:	
		</h4>
	</summary>
	<div>
		
	***forEach() ничего не возвращает***, а просто итерируется по исходному массиву. Более элегантный перебор, чем цикл for().
	***map()*** и ***filter()*** возвращают новый массив. Первый используется для трансформации и вернет массив элементов, к каждому из которых была применена функция-callback. Второй применяется для фильтрации и вернет массив из тех элементов, для которых функция-callback вернет true.
	***reduce()*** возвращает результат выполнения. Применяется для последовательной обработки элементов массива.
	
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Отличие стрелочных функция от функций, объявленных через function?</b> :left_right_arrow:	
		</h4>
	</summary>
	<div>
		
	- Синтаксис
	- Стрелочные функции не имеют arguments
	- У стрелочных функций нет своего this. Если идет обращение к this, то оно берется снаружи
	- Не могут быть вызваны с помощью  оператора new
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое шаблонные литералы и для чего они нужны?</b>
		</h4>
	</summary>
	<div>

	Шаблонные литералы - это ***косые кавычки***.
	- В них разрешен перенос строки
	- Можно вставлять выражения при помощи ${}
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое set и map?</b>
		</h4>
	</summary>
	<div>

	***Map*** - это коллекция ключ/значение, как и Object. Основное отличие в том, что Map позволяет использовать ключи любого типа.

	***Set*** - это коллекция (множество), совего рода массив, где каждое значение может появляться только один раз.
		
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Какие есть falsy значения?</b> :disguised_face:	
		</h4>
	</summary>
	<div>
		
	В JavaScript есть только ***7 ложных*** значений.
	Это означает, что когда JavaScript ожидает логическое значение и ему присваивается одно из значений ниже, оно всегда будет оцениваться как ложное:
	- false
	- 0
	- ""
	- null
	- undefined
	- NaN
	- BigInt(0)
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое Promise?</b> :ring:	
		</h4>
	</summary>
	<div>
		
	***Promise*** - это специальный объект, предназначенный для работы с асинхронным кодом и который содержит свое состояние. Вначеле ***pending***(«ожидание»), затем ***fulfilled***(«выполнено успешно») или ***rejected***(«выполнено с ошибкой»).
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Как использовать async/await для асинхронных запросов?</b> 
		</h4>
	</summary>
	<div>

	***Async/await*** - это специальный синтаксис для работы с промисами. То есть функция, помеченная async, будет ***оборачивать результат*** в Promise. 

	Функция помечается async, что позволяет использовать внутри await перед асинхронными операциями, что позволит выполнять код ***синхронно***.
	</div>
	</details>

	<details>
	<summary>
		<h4>
			<b>Для чего нужен оператор spread?</b> :wind_face:	
		</h4>
	</summary>
	<div>
	Оператор ... имеет множество предназначений. 
	Конкретно spread предназначен, чтобы разворачивать массивы и объекты.

	    let mid = [3,4];
	    let arr = [1,2,mid,5,6] // Получим [1,2,[3,4],5,6]

	    let mid = [3,4];
	    let arr = [1,2,...mid,5,6] // Получим [1,2,3,4,5,6]

	</div>
	</details>	
		
	<details>
	<summary>
		<h4>
			<b>Как избежать ссылочной зависимости при копировании объекта?</b> 
		</h4>
	</summary>
	<div>

	***Object.assign()*** для вложенных объектов скопирует только ссылку, то есть сложный объект будет скопирован только частично. 
		
	Давний костыльный способ `JSON.parse(JSON.stringify(object))`. То есть получим полную копию.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое тернарный оператор?</b> :three:	
		</h4>
	</summary>
	<div>

	Это аналогичный if - else оператор, который единственный имеет 3 аргумента. Представлен знаком `?`

    		let result = условие ? тогда : иначе;
	</div>
	</details>	
	
	<details>
	<summary>
		<h4>
			<b>Что такое деструктуризация?</b> :collision:	
		</h4>
	</summary>
	<div>

	***Деструктурирующее присваивание*** - специальный синтаксис, позволяющий распаковать массив/объект в переменные

	    let options = {
		title: "Menu",
		width: 50,
		height: 100
	    };

	    let {title,width,height} = options;
	</div>
	</details>	
		
	<details>
	<summary>
		<h4>
			<b>Какие способы работы с асинхронным кодом имеются?</b>
		</h4>
	</summary>
	<div>

	- ***callback*** - функция обратного вызова
	- ***Promise***
	- ***async/await*** - специальный синтаксис по работе с промисами
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Для чего нужны e.preventDefault() и e.stopPropagination?</b>
		</h4>
	</summary>
	<div>

	***event.preventDefault()*** - отмена обработки события по умолчанию
	***event.stopPropagination()*** - отключение всплытия событий в html, то есть отключение прослушки события родителей.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Как отслеживать и обрабатывать ошибки в JavaScript?</b>
		</h4>
	</summary>
	<div>

	Для этого существует ***специальная конструкция***:

	    try {
		// код
	    } catch (error) {
		// Код в этом блоке выполнится, если в блоке 
		// try произошла ошибка
	    } finally {
		// Код в этом блоке выполнится в любом случае
	    }

	Error содержит объект ошибки с подробной информацией.

	Links:
	- [СОБЕСЕДОВАНИЕ на FRONTEND разработчика JS CSS REACT VUE HTTP. Подготовка к собеседованию](https://youtu.be/gV6eobXisYU)

	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>По ссылке или по значению</b> :link:	
		</h4>
	</summary>
	<div>
		
	Примитивные типы передаются по значению, то есть копируются.
Массивы, объекты и др. более сложные типы данных передаются по ссылке. Если нужно, то копируем вручную.
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Область видимости (Scope)</b>
		</h4>
	</summary>
	<div>
		
	В самом простом понимании есть глобальная и локальная области видимости. Дочерняя область видимости имеет доступ к переменным из родительской области видимости.
	</div>
	</details>		
		
	<details>
	<summary>
		<h4>
			<b>Поднятие по области видимости(Hoisting)</b>
		</h4>
	</summary>
	<div>
		
	Помним, что ***var*** и определения некоторых вещей, как ***функции***, всплывает вверх области видимости.

		console.log(i) // выведет undefined, так как var i всплыл вверх, но операция присвавания не всплывает
		var i = 42
		console.log(i) // выведет 42

	 Переменные ***let*** и ***const*** не будут всплывать

	    	console.log(num) // ReferenceError - переменная не определена
	    	let num = 42
	    	console.log(num) // выведет 42

	***Function Declaration*** поднимается по области видимости

	    	function fun() {}

	***Function Expression*** не поднимается по области видимости

	    	const fun = function () {}
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Переменные let и const</b>
		</h4>
	</summary>
	<div>

	Переменные, созданные через ***let*** имеют блочную область видимости

	    	let a = 'Variable a'
	    	let b = 'Variable b'
	    	{
			a = 'New Variable A'
			let b = 'Local Variable b'
			console.log('Scope A', a) // выведет Variable a
			console.log('Scope B', b) // выведет Local Variable b
		     }
		     console.log('A:', a) // выведет Variable a
		     console.log('B:', b) // выведет Variable b

	Константные переменные ***const*** не дают менять свою ссылку

		    const  PORT  =  8080

		    PORT = 2000 // TypeError нельзя изменить 

	А вот элементы массива и объекта можно изменять, обращаться к ним.

	То есть ***const*** значит, что ссылку на эту переменную нельзя изменить после инициализации.
	</div>
	</details>		
		
	<details>
	<summary>
		<h4>
			<b>Замыкания</b> :infinity:
		</h4>
	</summary>
	<div>

	***Замыкания*** - это момент, когда функция имеет доступ до переменных из вышестоящего Scope. Функция замыкает в себе определенные значения из вышестоящего Scope.

	    function sayHelloTo(name) {
		const message = 'Hello ' + name
		return function() {
		     console.log(message) // функция замкнула переменную message
		}
	    }

	    const helloToElena = sayHelloTo('Elena')

	    helloToElena() // вернет Hello Elena

	Так можно создавать менеджеры

	    function createFrameworkManager() {
		const fw = ['Angular', 'React']
		    return {
		       print: function() {
			   console.log(fw.join(' '))
		       },
		       add: function(framework) {
			   fw.push(framework)
		       }
		     }
	    }

	    const manager = createFrameworkManager()
	    console.log(manager)
	    manager.print() // выведет Angular React
	    manager.add('VueJS') 
	    manager.print() // выведет Angular React Vue
	</div>
	</details>

	<details>
	<summary>
		<h4>
			<b>IIFE - Immediately Invoked Function Expression</b> :rotating_light:	
		</h4>
	</summary>
	<div>
	IIFE - способность создания функций, которые будут моментально вызваны

	    let  result  =  []

	    for (var i = 0; i < 5; i++) {
		(function() {
		     var j = i
		     result.push( function() { console.log(j) } )
		 })()
	    }

	    result[2]()
	    result[4]()
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Контекст</b> :page_facing_up:	
		</h4>
	</summary>
	<div>

	***Контекст*** - это то, что определяет, каким образом функция была вызвана. То есть указывает на ***this*** в текущем участке кода.

	    const person = {
		surname: 'Старк',
		knows: function (what, name) {
		  console.log(`Ты ${what} знаешь, ${name} ${this.surname}`)
		  }
		}
	    const john = { surname: 'Сноу' }

	    person.knows('все', 'Бран') // выведет Ты все знаешь, Бран Старк

	    person.knows.call(john, 'ничего не', 'Джон') // выведет Ты ничего не знаешь, Джон Сноу
	    person.knows.apply(john, ['ничего не', 'Джон']) // выведет Ты ничего не знаешь, Джон Сноу
	    person.knows.call(john, ...['ничего не', 'Джон']) // выведет Ты ничего не знаешь, Джон Сноу

	    const bound = person.knows.bind(john, 'ничего не', 'Джон')
	    bound()

	Метод ***call*** первым парметром принимает новый контекст, который в JS является объектом. Он ***сразу вызывает функцию*** с новым контекстом, принимая остальные параметры через запятую. То есть this будет указывать на jhon. Так же мы можем использовать массив, разворачивая его  с помощью **_spread operator (...[mass])_**.

	Метод ***apply***, который отличается только тем, что вторым параметром является массив дополнительных аргументов. 

	Метод ***bind*** отличается тем, что не вызывает функцию сразу, а ***возвращает новую функцию*** с заданным контекстом.

	Класс, созданный через new function позволяет использовать контекст (ES5)

	    function Person(name, age) {
		this.name = name
		this.age = age

		console.log(this)
	    }

	    const elena = new Person('Elena', 20) 
	    // this будет "классом" Person { name: 'Elena', age: '20"'}

	Мы можем ***явно передавать контекст*** в функцию через call, apply, bind.
	Мы можем ***неявно передавать контекст***

	    const animal = {
		legs: 4,
		logThis: function() {
		    console.log(this)
		}
	    }

	    animal.logThis() 
	    // к функции неявно привязался контекст объекта animal

	***Function*** создает себе новый собственный локальный контекс.
	***Стрелочные функции*** не имеют своего собственного контекста, а получают его извне.
	</div>
	</details>		
		
	<details>
	<summary>
		<h4>
			<b>Как работает New</b> :new:	
		</h4>
	</summary>
	<div>

	    function Cat(color, name) {
		this.color = color
		this.name = name
	    }

	    const cat = new Cat('black', 'KOT')
	    console.log(cat) // вернет Cat { color: 'black', name: 'КОТ'}

	    // как создать свой New
	    function myNew(constructor, ...args) {
		const obj = {}
		Object.setPrototypeOf(obj, constructor.prototype)
		return constructor.apply(obj, args) || obj
	    }

	    const cat = myNew(Cat, 'black', 'KOT')
	    console.log(cat) // вернет Cat { color: 'black', name: 'КОТ'}

	    const cat = Cat()
	    console.log(cat) // вернет undefined</div>
		
	***Оператор new*** создает экземпляр (***instance***) класса, основываясь на взаимодействии с базовым Object.
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Прототипы</b> :cyclone:	
		</h4>
	</summary>
	<div>

	Каждый объект имеет свой прототип, который берется от родительского элемента через ***свойство \_\_proto\_\_*** в ES6. 

	Наследование в JS является прототипированным, то есть по цепочке, по которой движок будет искать свойство сначала в классе, потом у его прототипа, потом у прототипа прототипа и т.д.

	В ES5 использовался метод **_Object.getPrototypeOf()_**. 
	Также прототип в другом контексте - это ***свойство функций prototype***, которое  служит для передачи свойств в том числе при создании через оператор new.

	    Cat.prototype.voice = function() {
		console.log(`Cat ${this.name} says myay`)
	    }

	    const cat = new Cat('Kot', 'white')

	    console.log(Cat.prototype) // выведет Cat { voice: [Function]}
	    console.log(cat) // выведет Cat { name: 'Kot', color: 'white' }
	    console.log(cat.__proto__ === Cat.prototype) // выведет true
	    console.log(cat.constructor) // выведет [Function]: Cat

	Расширение функционала класса через прототипы показано в примере выше.   ***ClassName.prototype*** является указателем на объект, который имеет конструктор и поля, которые будут добавлены для объектов, созданных на его базу.

	Проверка наличия свойства у объекта и его прототипов через **_('name' in obj)_**. 
	Проверка наличия свойства у только самого объекта obj.hasOwnProperty(PropertyName).

	***Object.create(protoObject, [свойства])*** создает объект на базе прототипа. 
	Изменение свойства прототипа приведет к изменению его во всех объектах, созданных на его основе.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Асинхронность в JS</b>
		</h4>
	</summary>
	<div>

	JS работает в 1 потоке, то есть не может быть асинхронным. Работа с асинхронностью доступна нам благодаря концепции ***EventLoop***. 
	Все setTimeout и т.п. работают на стороннем API.

	Link:
	-[# Подготовка к JavaScript собеседованию](https://youtu.be/M_pclb-58ZY)

	</div>
	</details>
				
- ### Angular :peach:	

	<details>
	<summary>
		<h4>
			<b>Что такое Guards?</b> :shield:	
		</h4>
	</summary>
	<div>

	***Guards*** - это сущность, которая помогает решать задачи связанные с доступом человека к странице.  Можно ли загрузить данный компонент?
	Наследуется от специальных интерфесов, например, ***CanActivate***,  ***CanActivateChild***. Возвращает ***true*** или ***false***, также может вернуть в формате ***Promise*** и ***Observable***. 

	Мы можем использовать в этих классах свои сервисы, что является плюсом.
	</div>
	</details>

	<details>
	<summary>
		<h4>
			<b>Что такое Modules и что в них входит?</b>
		</h4>
	</summary>
	<div>

	***Module*** - это набор сущностей с директивой ***@NgModule***. Имеет ***imports*** - для других модулей, ***providers*** - другие сервисы, ***declarations*** - компоненты, директивы и пайпы модуля, ***exports*** - публичные сущности модуля, ***bootstrap*** - компонент, с которого необходимо начать загрузку модуля.

	</div>
	</details>		
		
	<details>
	<summary>
		<h4>
			<b>В чем отличие AngularJS и Angular?</b> :business_suit_levitating: :man_dancing:	
		</h4>
	</summary>
	<div>

	Первая разработка Google - AngularJS. Содержал в себе контроль, директивы и т.п. Потом появился Angular 2, который по сути не имеет общего ничего, кроме названия. Его перименовали просто в Angular с версиями 2, 3 и т.п. Из отличий в Angular используется TypeScript, а контроллеры, директивы и т.п. находятся внутри декоратора @Component, также поддержка ES6 синтаксиса и Angular CLI.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое Component и зачем их использовать?</b> :jigsaw:	
		</h4>
	</summary>
	<div>

	***Component*** - базовый строительный блок приложения. Angular строится в виде дерева, где один компонент содержит внутри другие, образуя древовидную структуру. Компоненты определяются декоратором ***@Component*** с одним обязательным параметром ***template*** или ***templateUrl***, а также параметрами ***selector***, ***styleUrls*** и др. Компоненты должны принадлежать какому-либо модулю (параметр ***declarations***), чтобы Angular мог их отслеживать и использовать.
	</div>
	</details>

	<details>
	<summary>
		<h4>
			<b>Какие обязательные параметры имеет @Component?</b> 
		</h4>
	</summary>
	<div>

	Декоратор ***@Component*** обязательно ***должен иметь шабло***н, то есть ***template*** или ***templateUrl***. Selector не является оюязательным, потому что в тестах мы можем сами создавать host-компоненты, не содержащие селектор.
	</div>
	</details>

	<details>
	<summary>
		<h4>
			<b>Чем отличается модуль от компонента?</b>
		</h4>
	</summary>
	<div>

	***Компоненты*** контролируют html отображение. ***Модуль*** же содежит в себе компоненты, сервисы и т.п., определяя то, что есть в приложении в целом. ***Компонет - строительный блок***, **Модуль - коробочка, хранящая в себе все составные части приложения.**
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что такое сервисы и зачем они нужны?</b>
		</h4>
	</summary>
	<div>

	***Сервисы*** являются классом, где мы храним все данные. Компоненты хранят только визуальное представление. Таким образом мы ***отделяем данные от визуального представления***. Сервисы не взаимодействуют с html, с событиями, а только работают с данными, оставясь достаточно гибкой. По большей части являются Singleton, но мы имеем возможность создавать несколько экземпляров. 

	Сервисы за счет своей гибкости позволяют создавать сложные масштабируемые приложения.
	</div>
	</details>


	<details>
	<summary>
		<h4>
			<b>Разница между *ngIf и [hidden]?</b>
		</h4>
	</summary>
	<div>

	Директива ****ngIf*** полностью убирает элемент из ***DOM-дерева***, а атрибут ***[hidden]*** просто визуально скрывает, добавляя ***display: none***.

	****ngIf*** меняет html, а ***hidden*** не меняет html.
	</div>
	</details>


	<details>
	<summary>
		<h4>
			<b>Разница между @Component и @Directive</b>
		</h4>
	</summary>
	<div>

	***Компоненты*** отвечают за визуальное отображение и создают структуру приложения, а ***директивы*** задают модели поведения внутри html, например, добавление классов, событий, стилей, но не создают своей структуры и работают в рамках компоненты, где задают шаблонное поведение.

	***Компоненты создают структуру, внутри которой с помощью директивы мы задаем шаблонное поведение.***
	</div>
	</details>
		
	<details>
	<summary>
		<h4>
			<b>Что делает @HostBinding(['class.valid']) isValid: boolean?</b>
		</h4>
	</summary>
	<div>

	Декоратор @HostBinding по большей части используется в директивах. Мы привязываем динамический класс с названием valid к переменной isValid. То есть если переменная true, то применится класс valid к элементу с соответствующей директивой.

	</div>
	</details>

	<details>
	<summary>
		<h4>
			<b>Разница между структурной и атрибут директивой?</b>
		</h4>
	</summary>
	<div>

	***Структурные директивы*** могут менять шаблон, например, *ngIf и *ngFor.
	В Angular такие директивы ***помечаются "звездочкой"*** - "\*". ***Атрибут-директивы*** добавляют поведение, но не меняют шаблон. Например, ngStyle и ngClass.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое Observables?</b>
		</h4>
	</summary>
	<div>

	Это классы, которые реализуют соответсвующий паттерн проектирования. Активно используются благодаря встроенной библиотеке RxJS.

	Некоторые объекты могут создавать уведомления, если мы на них подписываемся, то являемся Observer. Если уведомление появляется, то мы сразу же получаем его во все местах. За счет этого работает рективная система внутри Angular.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое интерполяция?</b>
		</h4>
	</summary>
	<div>

	***Интерполяция*** - синтаксис, который позволяет выводить динамические данные в шаблон, например {{ index }}, то есть ***обозначает связку между шаблоном и фукцинальной частью компоненты***.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>В чем разница между Promise и Observable?</b>
		</h4>
	</summary>
	<div>

	Оба класса работают с асинхронным кодом и обрабатывают по сути результат. Promise заранее нельзя отменить, работает всегда с одним событием, то есть для каждого создаем свой Promise. Promise в любом случае будет выполнен, даже если нет никаких подписок (блок then), а Observable не выполнит асинхронный код, если нет подписчиков.

	Мы можем подписываться и отписываться от потоков, применять операторы, а у Promise такого нет.

	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Разница между constructor и ngOnInit?</b>
		</h4>
	</summary>
	<div>

	***Конструктор*** приходит из ES6 и вызывается при создании экземпляра класса, это первый этап взаимодействия. Angular же сам работает с конструктором и создает проверки и другие нужные ему вещи, подготавливая компонент к работе. Мы туда инжектируем сервисы и сущности.

	В ***жизненном цикле ngOnInit*** мы работаем с уже готовым к работе компонентом. Реализация его интерфейса является хорошей практикой для поддержки корректной работы. Например, в тестах иначе возникнут сложности.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое реактивное программирование в Angular?</b>
		</h4>
	</summary>
	<div>

	***Реактивное программирование*** - это программирование с асинхронными потоками данных. В основном работают со встроенной ***библиотекой RxJS***, хотя имеются и другие способы, такие как ***EventEmitter*** (внутри тоже содержит RxJS). 

	***RxJS*** позволяет работать с асинхронными потоками данных, которые в ядре содержат Observables. Позволяет работать с множеством операторов, которые позволяют изменять, фильтровать и т.д.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Зачем использовать spy в тестах?</b>
		</h4>
	</summary>
	<div>

	Angualr для тестирования использует фреймворк Jasmine, в котором есть эта функция spy.

	Функция позволяет шпионить за методами, возвращая мок-данные вместо реального обращения к backend, а также отслеживать и собирать статистику. Это позволяет создавать универсальные тесты.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое TestBed?</b>
		</h4>
	</summary>
	<div>

	Высокоуровневый фреймворк внутри Angular, позволяющий корректно тестировать и настраивать окружение. Мы можем создавать свои компоненты и т.п., подготавливаясь к интеграционному тестированию. ***Это набор инструментов, позволяющий реализовывать интеграционное тестирование***.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое Protractor?</b>
		</h4>
	</summary>
	<div>

	Это фреймворк предназначенный для end-to-end тестирования. Это программа для node.js, которая запускает тесты в реальном браузере и отображает информацию о действиях пользователя.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Как реализовать Resize элементов?</b>
		</h4>
	</summary>
	<div>

	Добавлением 
	`@HostListener('window:resize', ['$event'])
	  onResize(event){
	    //do something
	  }`             
	  AddEventListener не подходит для Angular. Встроенный декоратор @HostListener поддерживает глобальные window, document и body.

	$event передаваемую в функцию ниже переменую.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое AOT?</b>
		</h4>
	</summary>
	<div>

	***Ahead-of-time compiler*** - концепт, позволяющий заранее компилировать  структуру шаблона, потому что браузер не знаком с директивами и т.п. AOT заранее подготавливает структуру шаблона, получая более оптимизированное приложение. В проде ng build --prod используется по умолчанию.

	Приложения быстрее запускаются, Angular заранее убирает неиспользуемые элементы, а также сам компилятор. В Dev версии присутсвует в клиентской версии, а на проде его отсутсвие уменьшает вес сборки.

	Позволяет заранее подготовить Angular-приложение для оптимизации.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое ActivatedRoute?</b>
		</h4>
	</summary>
	<div>

	***ActivatedRoute*** - это интерфейс или класс, который мы можем инжектировать в наш компонент и сервис, чтобы получить доступ к текущему активному роуту, например, получить QueryParams с реактивностью или же статику через snapshot.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое динамические компоненты?</b>
		</h4>
	</summary>
	<div>

	***Динамические компоненты*** - это компоненты, положение которых заранее не определено в приложении. Они зарегестрированы, определены, но в шаблоне не используются. Мы можем их динамичсеки добавлять в DOM.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Какие функции несет в себе RxJS?</b>
		</h4>
	</summary>
	<div>

	***RxJS*** - это библиотека, которая позволяет нам работать с асинхронным кодом, а также преврашать его в Observables. 

	Мы можем превращать как статитку, так и асинхронный код в Observables и работать с ним, как с асинхронным. Несет функционал создания таких потоков данных. Может помогать перебирать массив поэтапно, маппить, фильтровать, приводить к единому значению через reduce, создавать композицию из потоков.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Как передавать параметры в Pipe?</b>
		</h4>
	</summary>
	<div>

	Мы можем передавать их последовательно ***через символ ":"***, а в самом Pipe мы можем получать их со 2ого по N. Первый параметр всегада значение.
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Какие типы binding существуют?</b>
		</h4>
	</summary>
	<div>

	- ***[disabled]*** - атрибуты (из компонента в шаблон)
	- ***{{title}}*** - интерполяция (из компонента в шаблон)
	- ***(mousedown)*** - события (из шаблона в компонент)
	- ***[(email)]*** - 2 way binding (в обе стороны - любое изменение в модели приводят к изменению шаблона и обратно) 
	</div>
	</details>		

	<details>
	<summary>
		<h4>
			<b>Что такое life cycle hooks?</b>
		</h4>
	</summary>
	<div>

	***Life cycle hooks*** - ловушки жизненного цикла компоненты:
	- ***constructor*** - как бы относится, но это из нативного языка
	- ***ngOnChanges*** - каждое изменение Input свойства (SimpleChanges)
	- ***ngOnInit*** - один раз после инициализации
	- ***ngDoCheck*** - начало механизма ChangeDetection
	- ***ngAfterContentInit (Component Only)*** - когда данные внутри компоненты получены
	- ***ngAfterContentChecked (Component Only)*** - когда ChangeDetection проверил контент
	- ***ngAfterViewInit (Component Only)*** - вызывается после выше. Готов отображение к работе
	- ***ngAfterViewChecked (Component Only)*** - вызывается после выше. После СhangeDetection для отображения
	- ***ngOnDestroy*** - вызывается перед уничтожение, в основном для отписок
	</div>
	</details>		
		
[//]: # "Шаблон"
	
<details>
<summary>
	<h4>
		<b>Шаблон</b>
	</h4>
</summary>
<div>

</div>
</details>
