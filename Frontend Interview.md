## **Change Detection**
В Angular есть два варианта работы алгоритма отслеживания изменений:
\- OnPush
\- Default (используется по умолчанию)

Алгоритм задается в свойстве changeDetection объекта конфигурации декоратора ***@Component*** и указывается для каждого компонента отдельно.

Angular по  умолчанию  использует ***ChangeDetectionStrategy.Default***:
Если что-то меняется в результате *пользовательских событий*, *таймеров* (_setTimeout_  или _setInterval_), *промисов*, *XMLHttpRequest*  и *т.п*., обнаружение будет запускаться по всем компонентам.

*Ключевую роль здесь играет библиотека `zone.js`. В Angular с ее помощью все приложение разделяется на секторы, каждый из которых запоминает контекст асинхронного выполнения. Такой подход после завершения асинхронной операции позволяет запустить механизм отслеживания изменений в нужном секторе.*

*Когда происходит асинхронное событие, Angular запускает обнаружение изменений в своем самом верхнем **_ViewRef_**, который после запуска обнаружения изменений сам запускает обнаружение изменений для своих дочерних представлений (метод **_detectChanges_**).*

Запуск механизма **ChangeDetection** в родительском компоненте автоматически инициирует запуск механизма во всех дочерних компонентах.

Этот цикл называется грязной проверкой (**_dirty checking_**). Суть проверки заключается в том, что Angular сравнивает новые значения со старыми и обновляет представление если они не равны.

**ChangeDetectionStrategy.OnPush**  альтернативная стратегия, которая запускается только в момент создания компонента (стадия жизненного цикла **_OnChanges_**) и делает компонент зависимым от **_@Input_**  параметров, и будет проверяться только при условиях:

 - **Изменилась ссылка input параметра**
Установив OnPush стратегию, мы как бы подписываем договор с Angular, который обязывает нас работать с иммутабельными объектами или наблюдаемыми (observables).<br/><br/>
*Неизменяемым (англ. immutable) называется объект, состояние которого не может быть изменено после создания. Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится.*<br/><br/>
Речь не идет о глубоком копировании: если объект имеет вложенную структуру, то все вложенные объекты, не подвергшиеся модификации, будут переиспользованы.<br/><br/>
Иммутабельность сильно упрощает нам задачу: вместо того, чтобы сравнивать значение каждого поля каждого вложенного в ***state*** объекта с соответствующим значением из ***nextState***, можно просто сравнивать ссылки на соответствующие объекты и отсеивать таким образом целые вложенные ветки сравнений.<br/><br/>
Преимущество работы с иммутабельными данными в контексте обнаружения изменений в том, что Angular выполняет простую проверку по ссылке, чтобы решить, следует ли проверять представление. Это намного быстрее чем глубокое сравнение объектов.<br/><br/>
То есть если мы изменим свойство объекта, то ссылка на объект останется той же, и проверка изменений не начнется, нужно именно изменить ссылку на объект.<br/><br/>
Link: [Иммутабельность](https://habr.com/ru/company/devexpress/blog/302118/)

 - **_Событие внутри компонента или его потомка_**
Компонент может иметь внутреннее состояние, которое обновляется, когда возникает событие от самого компонента или его потомков.<br/><br/>
Это работает не со всеми асинхронными событиями, а **_только с событиями DOM_**.

 - **_Ручной запуск обнаружения изменений_**
Angular предоставляет нам три метода для самостоятельного запуска механизма обнаружения изменений:

     - **detectChanges()** запускает обнаружение изменений в самом компоненте и его потомках.

   - **ApplicationRef.tick()** запускает обнаружение изменений во всем приложении.

   - **markForCheck()** **не запускает** обнаружение изменений. Он помечает компонент и всех его родителей, что они должны быть
   проверены в текущем или следующем цикле обнаружения изменений.

 - **_Async pipe_** Без использования **_| async_**  изменения отображаться не будут, так как не происходит ни одно из условий выше.<br/><br/>
*Async* пайп подписывается на наблюдаемый объект или промис и возвращает последнее отданное им значение. Когда приходит новое значение, async пайп отмечает компонент как необходимый к проверке.

- **_OnPush_** **_и шаблонные переменные_**
Если мы определяем input параметр через ***@ContentChild*** внутри кода, а не шаблона, то Angular не узнает, что мы обновили свойство в компоненте. Только определив input параметр в шаблоне, Angular поймет, что это свойство нужно проверить в следующем цикле обнаружения изменении, создав **updateRenderer()** функцию, которая отслеживает изменения значений параметров в каждом цикле обнаружения изменений.<br/><br/>
Можно решить с помощью создания сеттера и вызова **markForCheck****()**

### **_Сервис_** **_ChangeDetectorRef_**
Основные методы сервиса:
  - ***detach()*** - полностью отключает механизм ChangeDetection;
  - ***detectChanges()*** - принудительно запускает механизм отслеживания изменений;
  - ***reattach()*** - используется после вызова detach() для активации механизма ChangeDetection.

Действие всех трех методов распространяется только на тот компонент, в пределах которого вызываются эти методы.

Links:
+ [https://habr.com/ru/company/infopulse/blog/358860/](https://habr.com/ru/company/infopulse/blog/358860/)
+ [https://angdev.ru/doc/angular-change-detection/](https://angdev.ru/doc/angular-change-detection/)
+ [https://dev-gang.ru/article/vse-czto-vam-nuzhno-znat-o-change-detection-v-angular-s6rpx73job/](https://dev-gang.ru/article/vse-czto-vam-nuzhno-znat-o-change-detection-v-angular-s6rpx73job/) (Что-то на техническом)

## **SOLID**
***Основные плюсы***:
- Инкапсуляция отдельных сущностей 
- Прозрачная организация архитектуры

***Принципы***:
1. **Единой ответственности** (*Single Responsibility*)
У модуля должна быть только одна причина для изменения. Класс должен отвечать за что-то одно. <br/><br/>
Организация кода таким образом, чтобы в случае изменения задействовать наименьшее количество модулей(классов).<br/><br/>
Принцип позволяет:
   - Декомпозировать на независимые модули
   - Уменьшать количество связей между модулями
   - Изменять меньше классов при расширении функционала
   - Ограничивать влияние изменений на несвязные сущности

2. **Открытости и закрытости** (*Open-Closed*)
Модуль открыт для расширения и закрыт для изменения. Разработка устойчивого к изменениям приложения. Небольшое изменение класса не должно затрагивать большое количество связанных модулей.<br/><br/>
Принцип позволяет:
   - Проектировать модули, выполняющие только одну задачу
   - Вводить абстракции, через которые будет осуществляться связь сущностей
   - Рассширять имплементацию и защищать ее от изменений
   - Выносить место взаимодействия модулей в отдельную прозрачную сущность

3. **Подстановки Барбары Лисков** (*Liskov Substitution*)
Подклассы могут служить заменой своим суперклассам. Функции, использующие базовый тип должны уметь работать с его подтипами. Проектирование логики таким образом, чтобы классы-наследники могли  корректно использоваться вместо классов-родителей. <br/><br/>
*В общем случае, лучше использовать общий интерфейс, а не наследование, чтобы избежать излишних проверок.*<br/><br/>
Принцип позволяет:
   - Выявлять проблемные абстракции и скрытые связи между сущностями
   - Делать поведение модулей предсказуемым
   - Вводить ограничение на наследование, чтобы потомки не противоречили базовому поведению

4. **Разделение интерфейсов** (*Interface Segregation*)
Сущности не должны зависеть от интерфейсов, которые они не используют. Чтобы при наследовани потомки не получали неиспользуемый функционал от предка, для этого интерфейсы нужно декомпозировать.<br/><br/>
Принцип позволяет:
   - Уменьшать количество зависимостей между модулями
   - Избавляться от ненужной функциональности при наследовании
   - Затрагивать только нужные части, а не все зависящие модули, при изменении
   - Декомпозировать, то есть разделять сущности

5. **Инверсия зависимостей** (*Dependency Inversion*)
Модули высших уровней не должны зависеть от модулей низких уровней, а должны зависеть от абстракций. Абстракции же не должны зависеть от деталей, а, наоборот, детали должны зависеть от абстракций.<br/><br/>
Верхнеуровневые сущности не должны зависеть от нижнеуровневых реализация, а любые зависимости лучше всего выносить в абстракции, то есть инкапсулировать в отдельных сущностях. <br/><br/>
Принцип позволяет:
   - Уменьшать количество зависимостей между модулями, повышая простоту чтения, понимания и тестирования

Links:
+ [Короткое видео](https://youtu.be/A6wEkG4B38E)
