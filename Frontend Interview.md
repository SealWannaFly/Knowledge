## **Change Detection**
В Angular есть два варианта работы алгоритма отслеживания изменений:
\- OnPush
\- Default (используется по умолчанию)

Алгоритм задается в свойстве changeDetection объекта конфигурации декоратора ***@Component*** и указывается для каждого компонента отдельно.

Angular по  умолчанию  использует ***ChangeDetectionStrategy.Default***:
Если что-то меняется в результате *пользовательских событий*, *таймеров* (_setTimeout_  или _setInterval_), *промисов*, *XMLHttpRequest*  и *т.п*., обнаружение будет запускаться по всем компонентам.

*Ключевую роль здесь играет библиотека `zone.js`. В Angular с ее помощью все приложение разделяется на секторы, каждый из которых запоминает контекст асинхронного выполнения. Такой подход после завершения асинхронной операции позволяет запустить механизм отслеживания изменений в нужном секторе.*

*Когда происходит асинхронное событие, Angular запускает обнаружение изменений в своем самом верхнем **_ViewRef_**, который после запуска обнаружения изменений сам запускает обнаружение изменений для своих дочерних представлений (метод **_detectChanges_**).*

Запуск механизма **ChangeDetection** в родительском компоненте автоматически инициирует запуск механизма во всех дочерних компонентах.

Этот цикл называется грязной проверкой (**_dirty checking_**). Суть проверки заключается в том, что Angular сравнивает новые значения со старыми и обновляет представление если они не равны.

**ChangeDetectionStrategy.OnPush**  альтернативная стратегия, которая запускается только в момент создания компонента (стадия жизненного цикла **_OnChanges_**) и делает компонент зависимым от **_@Input_**  параметров, и будет проверяться только при условиях:

 - **Изменилась ссылка input параметра**
Установив OnPush стратегию, мы как бы подписываем договор с Angular, который обязывает нас работать с иммутабельными объектами или наблюдаемыми (observables).<br/><br/>
*Неизменяемым (англ. immutable) называется объект, состояние которого не может быть изменено после создания. Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится.*<br/><br/>
Речь не идет о глубоком копировании: если объект имеет вложенную структуру, то все вложенные объекты, не подвергшиеся модификации, будут переиспользованы.<br/><br/>
Иммутабельность сильно упрощает нам задачу: вместо того, чтобы сравнивать значение каждого поля каждого вложенного в ***state*** объекта с соответствующим значением из ***nextState***, можно просто сравнивать ссылки на соответствующие объекты и отсеивать таким образом целые вложенные ветки сравнений.<br/><br/>
Преимущество работы с иммутабельными данными в контексте обнаружения изменений в том, что Angular выполняет простую проверку по ссылке, чтобы решить, следует ли проверять представление. Это намного быстрее чем глубокое сравнение объектов.<br/><br/>
То есть если мы изменим свойство объекта, то ссылка на объект останется той же, и проверка изменений не начнется, нужно именно изменить ссылку на объект.<br/><br/>
Link: [Иммутабельность](https://habr.com/ru/company/devexpress/blog/302118/)

 - **_Событие внутри компонента или его потомка_**
Компонент может иметь внутреннее состояние, которое обновляется, когда возникает событие от самого компонента или его потомков.<br/><br/>
Это работает не со всеми асинхронными событиями, а **_только с событиями DOM_**.

 - **_Ручной запуск обнаружения изменений_**
Angular предоставляет нам три метода для самостоятельного запуска механизма обнаружения изменений:

     - **detectChanges()** запускает обнаружение изменений в самом компоненте и его потомках.

   - **ApplicationRef.tick()** запускает обнаружение изменений во всем приложении.

   - **markForCheck()** **не запускает** обнаружение изменений. Он помечает компонент и всех его родителей, что они должны быть
   проверены в текущем или следующем цикле обнаружения изменений.

 - **_Async pipe_** Без использования **_| async_**  изменения отображаться не будут, так как не происходит ни одно из условий выше.<br/><br/>
*Async* пайп подписывается на наблюдаемый объект или промис и возвращает последнее отданное им значение. Когда приходит новое значение, async пайп отмечает компонент как необходимый к проверке.

- **_OnPush_** **_и шаблонные переменные_**
Если мы определяем input параметр через ***@ContentChild*** внутри кода, а не шаблона, то Angular не узнает, что мы обновили свойство в компоненте. Только определив input параметр в шаблоне, Angular поймет, что это свойство нужно проверить в следующем цикле обнаружения изменении, создав **updateRenderer()** функцию, которая отслеживает изменения значений параметров в каждом цикле обнаружения изменений.<br/><br/>
Можно решить с помощью создания сеттера и вызова **markForCheck****()**

### **_Сервис_** **_ChangeDetectorRef_**
Основные методы сервиса:
  - ***detach()*** - полностью отключает механизм ChangeDetection;
  - ***detectChanges()*** - принудительно запускает механизм отслеживания изменений;
  - ***reattach()*** - используется после вызова detach() для активации механизма ChangeDetection.

Действие всех трех методов распространяется только на тот компонент, в пределах которого вызываются эти методы.

Links:
+ [https://habr.com/ru/company/infopulse/blog/358860/](https://habr.com/ru/company/infopulse/blog/358860/)
+ [https://angdev.ru/doc/angular-change-detection/](https://angdev.ru/doc/angular-change-detection/)
+ [https://dev-gang.ru/article/vse-czto-vam-nuzhno-znat-o-change-detection-v-angular-s6rpx73job/](https://dev-gang.ru/article/vse-czto-vam-nuzhno-znat-o-change-detection-v-angular-s6rpx73job/) (Что-то на техническом)

## **SOLID**
***Основные плюсы***:
- Инкапсуляция отдельных сущностей 
- Прозрачная организация архитектуры

***Принципы***:
1. **Единой ответственности** (*Single Responsibility*)
У модуля должна быть только одна причина для изменения. Класс должен отвечать за что-то одно. <br/><br/>
Организация кода таким образом, чтобы в случае изменения задействовать наименьшее количество модулей(классов).<br/><br/>
Принцип позволяет:
   - Декомпозировать на независимые модули
   - Уменьшать количество связей между модулями
   - Изменять меньше классов при расширении функционала
   - Ограничивать влияние изменений на несвязные сущности

2. **Открытости и закрытости** (*Open-Closed*)
Модуль открыт для расширения и закрыт для изменения. Разработка устойчивого к изменениям приложения. Небольшое изменение класса не должно затрагивать большое количество связанных модулей.<br/><br/>
Принцип позволяет:
   - Проектировать модули, выполняющие только одну задачу
   - Вводить абстракции, через которые будет осуществляться связь сущностей
   - Рассширять имплементацию и защищать ее от изменений
   - Выносить место взаимодействия модулей в отдельную прозрачную сущность

3. **Подстановки Барбары Лисков** (*Liskov Substitution*)
Подклассы могут служить заменой своим суперклассам. Функции, использующие базовый тип должны уметь работать с его подтипами. Проектирование логики таким образом, чтобы классы-наследники могли  корректно использоваться вместо классов-родителей. <br/><br/>
*В общем случае, лучше использовать общий интерфейс, а не наследование, чтобы избежать излишних проверок.*<br/><br/>
Принцип позволяет:
   - Выявлять проблемные абстракции и скрытые связи между сущностями
   - Делать поведение модулей предсказуемым
   - Вводить ограничение на наследование, чтобы потомки не противоречили базовому поведению

4. **Разделение интерфейсов** (*Interface Segregation*)
Сущности не должны зависеть от интерфейсов, которые они не используют. Чтобы при наследовани потомки не получали неиспользуемый функционал от предка, для этого интерфейсы нужно декомпозировать.<br/><br/>
Принцип позволяет:
   - Уменьшать количество зависимостей между модулями
   - Избавляться от ненужной функциональности при наследовании
   - Затрагивать только нужные части, а не все зависящие модули, при изменении
   - Декомпозировать, то есть разделять сущности

5. **Инверсия зависимостей** (*Dependency Inversion*)
Модули высших уровней не должны зависеть от модулей низких уровней, а должны зависеть от абстракций. Абстракции же не должны зависеть от деталей, а, наоборот, детали должны зависеть от абстракций.<br/><br/>
Верхнеуровневые сущности не должны зависеть от нижнеуровневых реализация, а любые зависимости лучше всего выносить в абстракции, то есть инкапсулировать в отдельных сущностях. <br/><br/>
Принцип позволяет:
   - Уменьшать количество зависимостей между модулями, повышая простоту чтения, понимания и тестирования

Links:
+ [Короткое видео](https://youtu.be/A6wEkG4B38E)
## **EventLoop**
JavaScript - однопоточный язык. Как выполняется асинхронный код? Для этого нужно рассмотреть цикл событий (EventLoop).<br/><br/>
EventLoop - это бесконечный цикл, который ожидает задачи, выполнят их и снова ожидвет поступление новых задач.<br/><br/>
*А как же тогда работает setTimeout(), слушатели событий и другие асинхронные операции? Эта функция на самом деле не принадлежит спецификации JavaScript, а предоставляется браузером (Web Api). Она вызывается у глобального объекта window. Функция принимает в себя первым параметром функцию-callback, а вторым параметром время ожидания в миллисекундах. 
Callback можно передавать в виде анонимной функции, можно по ссылке(без скобочек) уже имеющуюся.* <br/><br/>
Основные игроки:
- Стек вызова (Call Stack)
- Очередь задач (Callback queue)
- Web Apis
- Event Loop
<br/><br/>
Link: [Сервис для демонстрации работы](http://latentflip.com/loupe/)<br/><br/>

Синхронные операции добавляются в ***стек вызова*** и выполняются. Когда движок JS доходит до ***асинхронного кода***, то он регистрирует функцию-callback и вызывает функцию из нужного Web Api. После выполнения кода на стороне Web Api функция-callback попадает в ***очередь задач*** , где ждет до того момента, пока стек вызова не останется пустым. Когда ***стек вызова*** опустеет, самая старая задача из очереди задач переместится в ***стек вызова***.<br/><br/>
*Вопрос собеседований про setTimeout(function, 0) связан с тем, что результат работы асинхронной функции будет вызываться после всего имеющегося синхронного кода в стеке вызова, то есть пока стек вызова не опустеет.*<br/><br/>
Links:
- [Наглядная выжимка](https://youtu.be/377qAu37OTE)
- [Владилен Минин](https://youtu.be/vIZs5tH-HGQ)
## **RxJS**
Библиотека позволяет работать с синхронными и асинхронными функциями в удобном формате.

На потоки подписываемся с помощью ***.subscribe(() => {})***. Имеет 3 метода:
- ***next*** функция для обработки следующего значения
- ***error*** функция для обработки ошибок
- ***complete*** функция обработки завершения потока

Их можно передавать в виде объекта с соответсвующими ключами.
Отписываемся с помощью метода ***unsubscribe***

Классы:
- **Observable** наблюдатель по соответствующему паттерну проектирования. В конструкторе можем указывать через ***next*** передаваемого объекта observer следющие значения
- **Subject** тот же Observable, но имеет возможность добавлять новые элементы в поток вне конструктора. Стартового значения не имеет
- **BehaviorSubject** тот же Subject, только имеет в конструкторе стартовое значение. При подписке передает последнее значение
- **ReplaySubject** тот же Subject, но запоминает прошлые значения и воспроизводит их. Можно в конструкторе указать размер буфера, то есть количество запоминаемых событий

Операторы применяются последовательно внутри ***.pipe()***:
- **scan((accumulator, value) => {}, seed)** работает по типу reduce метода массивов. Seed - это начальное значение накопителя
- **reduce** обрабатывает завершенный поток
- ***map*** модифицирует поток
- **tap** получает каждое значение потока, но никак не влияет на данные
- **filter** фильтрует данные по заданному правилу
- **take** ограничивает поток заданным количеством элементов
- **takeLast** накапливает заданное количество последних значений и возвращает их
- **takeWhile** ограничивает поток по условию
- **switchMap** позволяет изменить текущий поток на другой поток
- [огромное количество других операторов](https://rxjs.dev/api)

Создание потоков:
- **of(1,2,3,4)** создает поток из последовательности аргументов
- **from([1,2,3,4])** создает поток из массива элементов
- ***fromEvent(selector, eventName)*** создает поток для событий
- **interval(period)** создает поток чисел счетчика через период
- **timer(dueTime)** аналогично setTimeout только с возможностью подписки
- **range(start, numberOfElements)** создает поток из N элементов от начального

Link:
- [Владилен Минин](https://youtu.be/gCwSVQO_PtY)
